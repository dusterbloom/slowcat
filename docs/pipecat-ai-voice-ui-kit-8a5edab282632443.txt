Directory structure:
â””â”€â”€ pipecat-ai-voice-ui-kit/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ components.json
    â”œâ”€â”€ eslint.config.js
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ tsconfig.tsbuildinfo
    â”œâ”€â”€ vite.config.ts
    â”œâ”€â”€ .npmignore
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ mdx-components.tsx
    â”‚   â”œâ”€â”€ next.config.mjs
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”œâ”€â”€ source.config.ts
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ vercel.json
    â”‚   â”œâ”€â”€ .eslintrc.json
    â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”œâ”€â”€ global.css
    â”‚   â”‚   â”œâ”€â”€ layout.config.tsx
    â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”œâ”€â”€ [[...slug]]/
    â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â””â”€â”€ api/
    â”‚   â”‚       â””â”€â”€ search/
    â”‚   â”‚           â””â”€â”€ route.ts
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â””â”€â”€ Sandbox.tsx
    â”‚   â”œâ”€â”€ content/
    â”‚   â”‚   â””â”€â”€ docs/
    â”‚   â”‚       â”œâ”€â”€ index.mdx
    â”‚   â”‚       â””â”€â”€ components/
    â”‚   â”‚           â””â”€â”€ button.mdx
    â”‚   â””â”€â”€ lib/
    â”‚       â””â”€â”€ source.ts
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ 01-console/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ app/
    â”‚   â”‚           â”œâ”€â”€ globals.css
    â”‚   â”‚           â”œâ”€â”€ layout.tsx
    â”‚   â”‚           â””â”€â”€ page.tsx
    â”‚   â”œâ”€â”€ 02-components/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ env.example
    â”‚   â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ app/
    â”‚   â”‚           â”œâ”€â”€ globals.css
    â”‚   â”‚           â”œâ”€â”€ layout.tsx
    â”‚   â”‚           â”œâ”€â”€ page.tsx
    â”‚   â”‚           â”œâ”€â”€ api/
    â”‚   â”‚           â”‚   â””â”€â”€ connect/
    â”‚   â”‚           â”‚       â””â”€â”€ route.ts
    â”‚   â”‚           â””â”€â”€ components/
    â”‚   â”‚               â””â”€â”€ App.tsx
    â”‚   â””â”€â”€ 03-app-helper/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ env.example
    â”‚       â”œâ”€â”€ eslint.config.mjs
    â”‚       â”œâ”€â”€ next.config.ts
    â”‚       â”œâ”€â”€ package.json
    â”‚       â”œâ”€â”€ postcss.config.mjs
    â”‚       â”œâ”€â”€ tsconfig.json
    â”‚       â””â”€â”€ src/
    â”‚           â””â”€â”€ app/
    â”‚               â”œâ”€â”€ app.tsx
    â”‚               â”œâ”€â”€ globals.css
    â”‚               â”œâ”€â”€ layout.tsx
    â”‚               â”œâ”€â”€ page.tsx
    â”‚               â””â”€â”€ api/
    â”‚                   â””â”€â”€ connect/
    â”‚                       â””â”€â”€ route.ts
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ icons.ts
    â”‚   â”œâ”€â”€ index.css
    â”‚   â”œâ”€â”€ index.ts
    â”‚   â”œâ”€â”€ vite-env.d.ts
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ ThemeModeToggle.tsx
    â”‚   â”‚   â”œâ”€â”€ ThemeProvider.tsx
    â”‚   â”‚   â”œâ”€â”€ ThemeProviderContext.tsx
    â”‚   â”‚   â”œâ”€â”€ elements/
    â”‚   â”‚   â”‚   â”œâ”€â”€ AudioOutput.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ClientStatus.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ClientStatus.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ConnectButton.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ConnectButton.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ControlBar.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ControlBar.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ Conversation.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ CopyText.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ DataList.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ DeviceDropDown.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ PipecatLogo.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ SessionInfo.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ Thinking.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ TranscriptOverlay.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ TranscriptOverlay.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ UserAudioControl.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ UserAudioControl.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ UserVideoControl.tsx
    â”‚   â”‚   â”œâ”€â”€ helpers/
    â”‚   â”‚   â”‚   â”œâ”€â”€ AudioClientHelper.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ metrics/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ Metrics.tsx
    â”‚   â”‚   â”œâ”€â”€ panels/
    â”‚   â”‚   â”‚   â”œâ”€â”€ BotAudioPanel.stories.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ BotAudioPanel.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ BotVideoPanel.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ ConversationPanel.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ EventsPanel.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ InfoPanel.tsx
    â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚       â”œâ”€â”€ banner.tsx
    â”‚   â”‚       â”œâ”€â”€ blankslates.tsx
    â”‚   â”‚       â”œâ”€â”€ button.stories.tsx
    â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚       â”œâ”€â”€ buttongroup.stories.tsx
    â”‚   â”‚       â”œâ”€â”€ buttongroup.tsx
    â”‚   â”‚       â”œâ”€â”€ buttonVariants.ts
    â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚       â”œâ”€â”€ container.tsx
    â”‚   â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚   â”‚       â”œâ”€â”€ error.stories.tsx
    â”‚   â”‚       â”œâ”€â”€ error.tsx
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚       â”œâ”€â”€ layout.tsx
    â”‚   â”‚       â”œâ”€â”€ loaders.tsx
    â”‚   â”‚       â”œâ”€â”€ panel.stories.tsx
    â”‚   â”‚       â”œâ”€â”€ panel.tsx
    â”‚   â”‚       â”œâ”€â”€ popover.tsx
    â”‚   â”‚       â”œâ”€â”€ resizable.tsx
    â”‚   â”‚       â”œâ”€â”€ select.stories.tsx
    â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚       â”œâ”€â”€ tabs.tsx
    â”‚   â”‚       â””â”€â”€ tooltip.tsx
    â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ useConversation.ts
    â”‚   â”‚   â””â”€â”€ useTheme.ts
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ dom.ts
    â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”œâ”€â”€ templates/
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â””â”€â”€ Console/
    â”‚   â”‚       â”œâ”€â”€ Console.stories.tsx
    â”‚   â”‚       â””â”€â”€ index.tsx
    â”‚   â””â”€â”€ visualizers/
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ CircularWaveform/
    â”‚       â”‚   â””â”€â”€ index.tsx
    â”‚       â”œâ”€â”€ VoiceVisualizer/
    â”‚       â”‚   â””â”€â”€ index.tsx
    â”‚       â””â”€â”€ webgl/
    â”‚           â”œâ”€â”€ index.ts
    â”‚           â”œâ”€â”€ Plasma.tsx
    â”‚           â””â”€â”€ PlasmaVisualizer.tsx
    â”œâ”€â”€ .github/
    â”‚   â””â”€â”€ workflows/
    â”‚       â”œâ”€â”€ build.yml
    â”‚       â”œâ”€â”€ publish-current.yml
    â”‚       â””â”€â”€ publish.yml
    â””â”€â”€ .ladle/
        â”œâ”€â”€ components.tsx
        â””â”€â”€ theme.css

================================================
FILE: README.md
================================================
# Pipecat Voice UI Kit
![NPM Version](https://img.shields.io/npm/v/@pipecat-ai/voice-ui-kit)

<img width="100%" src="image.png" />


Components, hooks and template apps for building React voice AI applications quickly. Designed to support and accelerate [Pipecat AI](https://github.com/pipecat-ai/pipecat) development.

- ğŸ”¬ **Debug console** â€“ Flexible, modular console UI to test and benchmark your Pipecat apps

- ğŸ”Œ **Headless components** â€“ Construct your own UIs with building blocks for voice, video, and real-time AI interactions

- ğŸš€ **Drop-in templates** â€“ Fully-featured, configurable UIs for developing and showcasing Pipecat apps

- ğŸ’… **Fully customizable** â€“ Built on Tailwind 4 and styled with CSS variables. Extend the built-in theme or bring your own

- ğŸ“± **Responsive design** â€“ Optimized for desktop, tablet, and mobile devices

- â­ **Example apps** â€“ Real-world implementations demonstrating best practices

## Quickstart

### Install the library

```shell
npm i @pipecat-ai/voice-ui-kit @pipecat-ai/client-js @pipecat-ai/client-react
```

_You will also have to install one of the supported transport packages_

```shell
npm i @pipecat-ai/daily-transport
# or
npm i @pipecat-ai/small-webrtc-transport
```

_Optional - install recommended fonts for default theme_:

```shell
npm i @fontsource-variable/geist @fontsource-variable/geist-mono
```

### Use the console template to chat with a Pipecat Bot:

```typescript
// Optional: recommended fonts
import "@fontsource-variable/geist";
import "@fontsource-variable/geist-mono";

// Styles
import "@pipecat-ai/voice-ui-kit/styles.css";

import { ConsoleTemplate, ThemeProvider } from "@pipecat-ai/voice-ui-kit";

// Render Console template in full screen container
export default function App() {
  return (
    <ThemeProvider>
      <div className="w-full h-dvh bg-background">
        <ConsoleTemplate
          onConnect={ async () => {
            // ... bot connect logic here
          }}
        />
      </div>
    </ThemeProvider>
  );
}
```

_Need a Pipecat agent to play with quickly? Check out this example and deploy in seconds to Pipecat Cloud!_

## What's included?

- How it's built, dependencies used etc

### Key dependencies

- Tailwind

- Shadcn & Radix

### How to use it

- Components
  - How to use, link to docs

- Elements
  - How to use, link to docs

- Voice visualizers
  - How to use, link to docs
  - Using WebGL visualizers

- Templates
  - How to use, link to docs

  - Figma file (coming soon)

## Styling and themeing

- Use with or without styles

- Customizing the included theme
  - shadcn variables list
  - TW4 variables list
  - changing the icon liberary

- Scoping to avoid conflicts
- working with TW3

## Example projects

- Links out

## Working with the framework

### Extending with your own components

- Ladle / component stories



================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": "vkui"
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}



================================================
FILE: eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import prettier from 'eslint-plugin-prettier'
import eslintConfigPrettier from 'eslint-config-prettier'

export default tseslint.config(
  { ignores: ['dist', 'examples'] },
  {
    extends: [
      js.configs.recommended, 
      ...tseslint.configs.recommended,
      eslintConfigPrettier
    ],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
      'prettier': prettier
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'sort-imports': [
        'warn',
        {
          ignoreDeclarationSort: true,
          ignoreCase: true,
          allowSeparatedGroups: true,
        },
      ],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      'prettier/prettier': 'error'
    },
  },
)



================================================
FILE: LICENSE
================================================
BSD 2-Clause License

Copyright (c) 2024â€“2025, Daily

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


================================================
FILE: package.json
================================================
{
  "name": "@pipecat-ai/voice-ui-kit",
  "version": "0.1.1",
  "type": "module",
  "license": "BSD-2-Clause",
  "workspaces": [
    "docs",
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "github:pipecat-ai/voice-ui-kit"
  },
  "author": "Daily (https://daily.co)",
  "contributors": [
    {
      "name": "Christian Stuff",
      "url": "https://github.com/Regaddi"
    },
    {
      "name": "Jon Taylor",
      "url": "https://github.com/jptaylor"
    }
  ],
  "main": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./webgl": {
      "types": "./dist/webgl.d.ts",
      "import": "./dist/webgl.mjs",
      "require": "./dist/webgl.cjs"
    },
    "./styles": "./dist/voice-ui-kit.css",
    "./styles.css": "./dist/voice-ui-kit.css",
    "./styles.scoped": "./dist/voice-ui-kit-scoped.css",
    "./styles.scoped.css": "./dist/voice-ui-kit-scoped.css"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "peerDependencies": {
    "@daily-co/daily-js": ">=0.80.0",
    "@pipecat-ai/client-js": ">=1.0.1",
    "@pipecat-ai/client-react": ">=1.0.1",
    "@pipecat-ai/daily-transport": ">=1.0.0",
    "@pipecat-ai/small-webrtc-transport": ">=1.0.0",
    "react": ">=16.8.0 || >=17.0.0 || >=18.0.0",
    "react-dom": ">=16.8.0 || >=17.0.0 || >=18.0.0",
    "three": ">=0.140.0"
  },
  "peerDependenciesMeta": {
    "@daily-co/daily-js": {
      "optional": false,
      "version": "^0.80.0"
    },
    "@pipecat-ai/client-js": {
      "optional": false,
      "version": "^1.0.1"
    },
    "@pipecat-ai/client-react": {
      "optional": false,
      "version": "^1.0.1"
    },
    "@pipecat-ai/daily-transport": {
      "optional": true,
      "version": "^1.0.0"
    },
    "@pipecat-ai/small-webrtc-transport": {
      "optional": true,
      "version": "^1.0.0"
    },
    "three": {
      "optional": true
    }
  },
  "scripts": {
    "build": "tsc -b && vite build",
    "build:watch": "vite build --watch",
    "lint": "eslint .",
    "ladle": "npx ladle serve"
  },
  "dependencies": {
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-tooltip": "^1.2.7",
    "chart.js": "^4.4.9",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "fast-deep-equal": "^3.1.3",
    "lucide-react": "^0.511.0",
    "react-chartjs-2": "^5.3.0",
    "react-resizable-panels": "^3.0.3",
    "tailwind-merge": "^3.3.0"
  },
  "devDependencies": {
    "@daily-co/daily-js": "^0.80.0",
    "@eslint/js": "^9.25.0",
    "@ladle/react": "^5.0.3",
    "@pipecat-ai/client-js": "^1.0.1",
    "@pipecat-ai/client-react": "^1.0.1",
    "@pipecat-ai/daily-transport": "^1.0.0",
    "@pipecat-ai/small-webrtc-transport": "^1.0.0",
    "@tailwindcss/vite": "^4.1.11",
    "@types/node": "^22.15.19",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@types/three": "^0.177.0",
    "@vitejs/plugin-react": "^4.4.1",
    "buffer": "^6.0.3",
    "eslint": "^9.25.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "i": "^0.3.7",
    "npm": "^11.4.2",
    "postcss-nested": "^7.0.2",
    "postcss-prefix-selector": "^2.1.1",
    "postcss-prefixwrap": "^1.55.0",
    "prettier": "^3.5.3",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwindcss": "^4.1.7",
    "three": "^0.160.0",
    "tw-animate-css": "^1.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5",
    "vite-plugin-dts": "^4.5.4"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "target": "ES2022",
    "lib": ["ES2023", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "docs/**/*", "**/*.test.*"]
}



================================================
FILE: tsconfig.tsbuildinfo
================================================
{"root":["./src/icons.ts","./src/index.ts","./src/vite-env.d.ts","./src/components/thememodetoggle.tsx","./src/components/themeprovider.tsx","./src/components/themeprovidercontext.tsx","./src/components/elements/audiooutput.tsx","./src/components/elements/clientstatus.stories.tsx","./src/components/elements/clientstatus.tsx","./src/components/elements/connectbutton.stories.tsx","./src/components/elements/connectbutton.tsx","./src/components/elements/controlbar.stories.tsx","./src/components/elements/controlbar.tsx","./src/components/elements/conversation.tsx","./src/components/elements/copytext.tsx","./src/components/elements/datalist.tsx","./src/components/elements/devicedropdown.tsx","./src/components/elements/pipecatlogo.tsx","./src/components/elements/sessioninfo.tsx","./src/components/elements/thinking.tsx","./src/components/elements/transcriptoverlay.stories.tsx","./src/components/elements/transcriptoverlay.tsx","./src/components/elements/useraudiocontrol.stories.tsx","./src/components/elements/useraudiocontrol.tsx","./src/components/elements/uservideocontrol.tsx","./src/components/elements/index.ts","./src/components/helpers/audioclienthelper.tsx","./src/components/helpers/index.ts","./src/components/metrics/metrics.tsx","./src/components/metrics/index.ts","./src/components/panels/botaudiopanel.stories.tsx","./src/components/panels/botaudiopanel.tsx","./src/components/panels/botvideopanel.tsx","./src/components/panels/conversationpanel.tsx","./src/components/panels/eventspanel.tsx","./src/components/panels/infopanel.tsx","./src/components/panels/index.ts","./src/components/ui/banner.tsx","./src/components/ui/blankslates.tsx","./src/components/ui/button.stories.tsx","./src/components/ui/button.tsx","./src/components/ui/buttonvariants.ts","./src/components/ui/buttongroup.stories.tsx","./src/components/ui/buttongroup.tsx","./src/components/ui/card.tsx","./src/components/ui/container.tsx","./src/components/ui/dropdown-menu.tsx","./src/components/ui/error.stories.tsx","./src/components/ui/error.tsx","./src/components/ui/index.ts","./src/components/ui/input.tsx","./src/components/ui/layout.tsx","./src/components/ui/loaders.tsx","./src/components/ui/panel.stories.tsx","./src/components/ui/panel.tsx","./src/components/ui/popover.tsx","./src/components/ui/resizable.tsx","./src/components/ui/select.stories.tsx","./src/components/ui/select.tsx","./src/components/ui/tabs.tsx","./src/components/ui/tooltip.tsx","./src/hooks/index.ts","./src/hooks/useconversation.ts","./src/hooks/usetheme.ts","./src/lib/dom.ts","./src/lib/utils.ts","./src/templates/index.ts","./src/templates/console/console.stories.tsx","./src/templates/console/index.tsx","./src/visualizers/index.ts","./src/visualizers/circularwaveform/canvas.ts","./src/visualizers/circularwaveform/index.tsx","./src/visualizers/voicevisualizer/index.tsx","./src/visualizers/webgl/plasma.tsx","./src/visualizers/webgl/plasmavisualizer.tsx","./src/visualizers/webgl/index.ts"],"version":"5.8.3"}


================================================
FILE: vite.config.ts
================================================
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import fs from "fs";
import path from "path";
import postcss from "postcss";
import prefixer from "postcss-prefix-selector";
import { defineConfig } from "vite";
import dts from "vite-plugin-dts";

function dualCssPlugin() {
  return {
    name: "dual-css",
    closeBundle() {
      const cssPath = path.resolve(__dirname, "dist/voice-ui-kit.css");

      if (fs.existsSync(cssPath)) {
        const cssContent = fs.readFileSync(cssPath, "utf-8");

        postcss([
          prefixer({
            prefix: ".vkui-root",
          }),
        ])
          .process(cssContent, { from: undefined })
          .then((result) => {
            const scopedCssPath = path.resolve(
              __dirname,
              "dist/voice-ui-kit-scoped.css",
            );
            fs.writeFileSync(scopedCssPath, result.css);
          });
      }
    },
  };
}

export default defineConfig({
  plugins: [
    tailwindcss(),
    react(),
    dts({
      insertTypesEntry: true,
      exclude: ["**/*.stories.*", "**/*.test.*"],
      outDir: "dist",
      rollupTypes: true,
    }),
    dualCssPlugin(),
  ],

  css: {
    postcss: {
      plugins: [],
    },
  },

  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },

  build: {
    lib: {
      entry: {
        index: path.resolve(__dirname, "src/index.ts"),
        metrics: path.resolve(__dirname, "src/components/metrics/index.ts"),
        webgl: path.resolve(__dirname, "src/visualizers/webgl/index.ts"),
      },
      formats: ["es", "cjs"],
      fileName: (format, entryName) =>
        `${entryName}.${format === "es" ? "mjs" : "cjs"}`,
    },

    rollupOptions: {
      external: [
        "react",
        "react-dom",
        "react/jsx-runtime",
        "@daily-co/daily-js",
        "@pipecat-ai/client-js",
        "@pipecat-ai/client-react",
        "@pipecat-ai/daily-transport",
        "@pipecat-ai/small-webrtc-transport",
      ],

      output: {
        globals: {
          "@daily-co/daily-js": "Daily",
          react: "React",
          "react-dom": "ReactDOM",
        },
      },
    },

    minify: false,
    sourcemap: true,
  },
});



================================================
FILE: .npmignore
================================================
.parcel-cache
src
components.json
.gitignore
.parcelrc
.postcssrc
.prettierrc


================================================
FILE: .prettierrc
================================================
{}



================================================
FILE: docs/README.md
================================================
# voice-kit-ui

This is a Next.js application generated with
[Create Fumadocs](https://github.com/fuma-nama/fumadocs).

Run development server:

```bash
npm run dev
# or
pnpm dev
# or
yarn dev
```

Open http://localhost:3000 with your browser to see the result.

## Explore

In the project, you can see:

- `lib/source.ts`: Code for content source adapter, [`loader()`](https://fumadocs.dev/docs/headless/source-api) provides the interface to access your content.
- `app/layout.config.tsx`: Shared options for layouts, optional but preferred to keep.

| Route                     | Description                                            |
| ------------------------- | ------------------------------------------------------ |
| `app/(home)`              | The route group for your landing page and other pages. |
| `app/docs`                | The documentation layout and pages.                    |
| `app/api/search/route.ts` | The Route Handler for search.                          |

### Fumadocs MDX

A `source.config.ts` config file has been included, you can customise different options like frontmatter schema.

Read the [Introduction](https://fumadocs.dev/docs/mdx) for further details.

## Learn More

To learn more about Next.js and Fumadocs, take a look at the following
resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js
  features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.
- [Fumadocs](https://fumadocs.vercel.app) - learn about Fumadocs



================================================
FILE: docs/mdx-components.tsx
================================================
import { Sandbox } from "@/components/Sandbox";
import defaultMdxComponents from "fumadocs-ui/mdx";
import type { MDXComponents } from "mdx/types";

// use this function to get MDX components, you will need it for rendering MDX
export function getMDXComponents(components?: MDXComponents): MDXComponents {
  return {
    ...defaultMdxComponents,
    ...components,
    Sandbox,
  };
}



================================================
FILE: docs/next.config.mjs
================================================
import { createMDX } from "fumadocs-mdx/next";

const withMDX = createMDX();

/** @type {import('next').NextConfig} */
const config = {
  reactStrictMode: true,
  transpilePackages: ["@pipecat-ai/voice-ui-kit"],
};

export default withMDX(config);



================================================
FILE: docs/package.json
================================================
{
  "name": "@pipecat-ai/voice-ui-kit-docs",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "build": "next build",
    "dev": "next dev --turbo",
    "start": "next start",
    "postinstall": "fumadocs-mdx"
  },
  "dependencies": {
    "next": "15.4.2",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "fumadocs-ui": "15.6.5",
    "fumadocs-core": "15.6.5",
    "fumadocs-mdx": "11.7.0",
    "@pipecat-ai/voice-ui-kit": "*"
  },
  "devDependencies": {
    "@types/node": "24.0.15",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "typescript": "^5.8.3",
    "@types/mdx": "^2.0.13",
    "@tailwindcss/postcss": "^4.1.11",
    "tailwindcss": "^4.1.11",
    "postcss": "^8.5.6",
    "eslint": "^8",
    "eslint-config-next": "15.4.2"
  }
}


================================================
FILE: docs/postcss.config.mjs
================================================
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};



================================================
FILE: docs/source.config.ts
================================================
import {
  defineConfig,
  defineDocs,
  frontmatterSchema,
  metaSchema,
} from 'fumadocs-mdx/config';

// You can customise Zod schemas for frontmatter and `meta.json` here
// see https://fumadocs.vercel.app/docs/mdx/collections#define-docs
export const docs = defineDocs({
  docs: {
    schema: frontmatterSchema,
  },
  meta: {
    schema: metaSchema,
  },
});

export default defineConfig({
  mdxOptions: {
    // MDX options
  },
});



================================================
FILE: docs/tsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "target": "ESNext",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/.source": ["./.source/index.ts"],
      "@/*": ["./*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: docs/vercel.json
================================================
{
    "buildCommand": "cd .. && npm install --include=dev && npm run build && cd docs && npm run build",
    "installCommand": "cd .. && npm install --include=dev",
    "outputDirectory": ".next"
}


================================================
FILE: docs/.eslintrc.json
================================================
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}



================================================
FILE: docs/app/global.css
================================================
@import "tailwindcss";
@import "fumadocs-ui/css/neutral.css";
@import "fumadocs-ui/css/preset.css";



================================================
FILE: docs/app/layout.config.tsx
================================================
import type { BaseLayoutProps } from "fumadocs-ui/layouts/shared";

export const baseOptions: BaseLayoutProps = {
  nav: {
    title: (
      <>
        <svg
          width="24"
          height="24"
          xmlns="http://www.w3.org/2000/svg"
          aria-label="Logo"
        >
          <circle cx={12} cy={12} r={12} fill="currentColor" />
        </svg>
        Voice UI Kit
      </>
    ),
  },
};



================================================
FILE: docs/app/layout.tsx
================================================
import "@/app/global.css";
import { baseOptions } from "@/app/layout.config";
import { source } from "@/lib/source";
import { DocsLayout } from "fumadocs-ui/layouts/docs";
import { RootProvider } from "fumadocs-ui/provider";
import { Inter } from "next/font/google";
import type { ReactNode } from "react";

const inter = Inter({
  subsets: ["latin"],
});

export default function Layout({ children }: { children: ReactNode }) {
  return (
    <html lang="en" className={inter.className} suppressHydrationWarning>
      <body className="flex flex-col min-h-screen">
        <RootProvider>
          <DocsLayout tree={source.pageTree} {...baseOptions}>
            {children}
          </DocsLayout>
        </RootProvider>
      </body>
    </html>
  );
}



================================================
FILE: docs/app/[[...slug]]/page.tsx
================================================
import { source } from '@/lib/source';
import {
  DocsPage,
  DocsBody,
  DocsDescription,
  DocsTitle,
} from 'fumadocs-ui/page';
import { notFound } from 'next/navigation';
import { createRelativeLink } from 'fumadocs-ui/mdx';
import { getMDXComponents } from '@/mdx-components';

export default async function Page(props: {
  params: Promise<{ slug?: string[] }>;
}) {
  const params = await props.params;
  const page = source.getPage(params.slug);
  if (!page) notFound();

  const MDXContent = page.data.body;

  return (
    <DocsPage toc={page.data.toc} full={page.data.full}>
      <DocsTitle>{page.data.title}</DocsTitle>
      <DocsDescription>{page.data.description}</DocsDescription>
      <DocsBody>
        <MDXContent
          components={getMDXComponents({
            // this allows you to link to other pages with relative file paths
            a: createRelativeLink(source, page),
          })}
        />
      </DocsBody>
    </DocsPage>
  );
}

export async function generateStaticParams() {
  return source.generateParams();
}

export async function generateMetadata(props: {
  params: Promise<{ slug?: string[] }>;
}) {
  const params = await props.params;
  const page = source.getPage(params.slug);
  if (!page) notFound();

  return {
    title: page.data.title,
    description: page.data.description,
  };
}



================================================
FILE: docs/app/api/search/route.ts
================================================
import { source } from '@/lib/source';
import { createFromSource } from 'fumadocs-core/search/server';

export const { GET } = createFromSource(source, {
  // https://docs.orama.com/open-source/supported-languages
  language: 'english',
});



================================================
FILE: docs/components/Sandbox.tsx
================================================
"use client";
import React, { useEffect, useState } from "react";

import "@pipecat-ai/voice-ui-kit/styles.scoped";

let uiKitModule: any = null;
let uiKitPromise: Promise<any> | null = null;

async function getUiKitModule() {
  if (uiKitModule) return uiKitModule;
  if (uiKitPromise) return uiKitPromise;

  uiKitPromise = import("@pipecat-ai/voice-ui-kit");
  uiKitModule = await uiKitPromise;
  return uiKitModule;
}

export function Sandbox({
  componentName,
  props = {},
  children,
}: {
  componentName: string;
  props?: Record<string, any>;
  children?: React.ReactNode;
}) {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(
    null,
  );
  const [isLoading, setIsLoading] = useState(true);
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  useEffect(() => {
    if (!isClient) return;

    getUiKitModule()
      .then((module) => {
        const ComponentFromModule = module[componentName];
        if (!ComponentFromModule) {
          console.error(`Component '${componentName}' not found in UI kit.`);
          return;
        }

        setComponent(() => ComponentFromModule);
        setIsLoading(false);
      })
      .catch((error) => {
        console.error("Failed to load sandbox resources:", error);
      });
  }, [componentName, isClient]);

  if (!isClient) {
    return (
      <div className="flex items-center justify-center p-4 text-sm text-muted-foreground">
        Loading component...
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-4 text-sm text-muted-foreground">
        Loading component...
      </div>
    );
  }

  if (!Component) {
    return (
      <div className="flex items-center justify-center p-4 text-sm text-muted-foreground">
        Component not found
      </div>
    );
  }

  return (
    <div className="vkui-root">
      <Component {...props}>{children}</Component>
    </div>
  );
}



================================================
FILE: docs/content/docs/index.mdx
================================================
---
title: Quickstart
description: Get started with the Voice UI Kit
---



================================================
FILE: docs/content/docs/components/button.mdx
================================================
---
title: Button
description: Displays a button or a component that looks like a button.
featured: true
component: true
---

<Sandbox componentName="Button" props={{ variant: "default" }}>
  Click me!
</Sandbox>

<Sandbox componentName="Button" props={{ variant: "secondary" }}>
  Click me!
</Sandbox>

<Sandbox componentName="Button" props={{ variant: "destructive" }}>
  Click me!
</Sandbox>

<Sandbox componentName="Button" props={{ variant: "outline" }}>
  Click me!
</Sandbox>

<Sandbox componentName="Button" props={{ variant: "ghost" }}>
  Click me!
</Sandbox>

<Sandbox componentName="Button" props={{ variant: "link" }}>
  Click me!
</Sandbox>



================================================
FILE: docs/lib/source.ts
================================================
import { docs } from "@/.source";
import { loader } from "fumadocs-core/source";

// See https://fumadocs.vercel.app/docs/headless/source-api for more info
export const source = loader({
  // it assigns a URL to your pages
  baseUrl: "/",
  source: docs.toFumadocsSource(),
});



================================================
FILE: examples/01-console/README.md
================================================
# Voice UI KIt - Console Template Example

This example shows how to implement the Console UI template.

It uses NextJS to demonstrate implementing a server-side route to handle bot start to protect API keys.

## Quickstart

Install node modules and chosen Pipecat client transport:

```shell
npm i 
npm i @pipecat-ai/small-webrtc-transport
# or
npm i @pipecat-ai/daily-transport
```

Create project `.env` file and set bot start endpoint and public API key (if relevant):

```shell
BOT_START_URL="https://..."
BOT_START_PUBLIC_API_KEY="abcxyz"
```

Run the application:

```shell
npm run dev
```


================================================
FILE: examples/01-console/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: examples/01-console/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async rewrites() {
    return [
      {
        source: "/api/:path*",
        destination: "http://0.0.0.0:7860/api/:path*",
      },
    ];
  },
};

export default nextConfig;



================================================
FILE: examples/01-console/package.json
================================================
{
  "name": "01-console",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.3.4",
    "@pipecat-ai/voice-ui-kit": "file:../../"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "@eslint/eslintrc": "^3"
  }
}


================================================
FILE: examples/01-console/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: examples/01-console/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: examples/01-console/src/app/globals.css
================================================
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

.vkui\:dark {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans);
}



================================================
FILE: examples/01-console/src/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";

import "./globals.css";

import "@pipecat-ai/voice-ui-kit/styles.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Voice UI Kit - Console Template Example",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



================================================
FILE: examples/01-console/src/app/page.tsx
================================================
"use client";

import {
  ConsoleTemplate,
  FullScreenContainer,
  ThemeProvider,
} from "@pipecat-ai/voice-ui-kit";

export default function Home() {
  return (
    <ThemeProvider>
      <FullScreenContainer>
        <ConsoleTemplate
          transportType="smallwebrtc"
          connectParams={{
            connectionUrl: "/api/offer",
          }}
          noUserVideo={true}
        />
      </FullScreenContainer>
    </ThemeProvider>
  );
}



================================================
FILE: examples/02-components/README.md
================================================
# Voice UI KIt - Console Template Example

This example shows how to implement the Console UI template.

It uses NextJS to demonstrate implementing a server-side route to handle bot start to protect API keys.

## Quickstart

Install node modules and chosen Pipecat client transport:

```shell
npm i 
npm i @pipecat-ai/small-webrtc-transport
# or
npm i @pipecat-ai/daily-transport
```

Create project `.env` file and set bot start endpoint and public API key (if relevant):

```shell
BOT_START_URL="https://..."
BOT_START_PUBLIC_API_KEY="abcxyz"
```

Run the application:

```shell
npm run dev
```


================================================
FILE: examples/02-components/env.example
================================================
BOT_START_URL=""
BOT_START_PUBLIC_API_KEY=""


================================================
FILE: examples/02-components/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: examples/02-components/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {};

export default nextConfig;



================================================
FILE: examples/02-components/package.json
================================================
{
  "name": "02-components",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@pipecat-ai/voice-ui-kit": "file:../../",
    "next": "15.3.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tw-animate-css": "^1.3.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}



================================================
FILE: examples/02-components/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: examples/02-components/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: examples/02-components/src/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@import "@pipecat-ai/voice-ui-kit/styles";



================================================
FILE: examples/02-components/src/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";

import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Voice UI Kit - Component UI Example",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



================================================
FILE: examples/02-components/src/app/page.tsx
================================================
"use client";

import { FullScreenContainer, ThemeProvider } from "@pipecat-ai/voice-ui-kit";
import { App } from "./components/App";

export default function Home() {
  return (
    <ThemeProvider>
      <FullScreenContainer>
        <App
          transportType="daily"
          connectParams={{
            endpoint: "/api/connect",
          }}
        />
      </FullScreenContainer>
    </ThemeProvider>
  );
}



================================================
FILE: examples/02-components/src/app/api/connect/route.ts
================================================
import { NextResponse } from "next/server";

export async function POST() {
  // Check if required environment variables are set
  if (!process.env.BOT_START_URL) {
    return NextResponse.json(
      { error: "BOT_START_URL environment variable is not configured" },
      { status: 500 },
    );
  }

  try {
    // Prepare headers - make API key optional
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    // Only add Authorization header if API key is provided
    if (process.env.BOT_START_PUBLIC_API_KEY) {
      headers.Authorization = `Bearer ${process.env.BOT_START_PUBLIC_API_KEY}`;
    }

    const response = await fetch(process.env.BOT_START_URL, {
      method: "POST",
      mode: "cors",
      headers,
      body: JSON.stringify({
        createDailyRoom: true,
      }),
    });

    if (!response.ok) {
      throw new Error(`Failed to connect to Pipecat: ${response.statusText}`);
    }

    const data = await response.json();

    if (data.error) {
      throw new Error(data.error);
    }

    return NextResponse.json({
      room_url: data.dailyRoom,
      token: data.dailyToken,
    }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { error: `Failed to process connection request: ${error}` },
      { status: 500 },
    );
  }
}



================================================
FILE: examples/02-components/src/app/components/App.tsx
================================================
import {
  ConnectionEndpoint,
  PipecatClient,
  TransportConnectionParams,
  TransportState,
} from "@pipecat-ai/client-js";
import {
  PipecatClientAudio,
  PipecatClientProvider,
} from "@pipecat-ai/client-react";
import { DailyTransport } from "@pipecat-ai/daily-transport";
import { SmallWebRTCTransport } from "@pipecat-ai/small-webrtc-transport";
import {
  Card,
  CardContent,
  ConnectButton,
  ControlBar,
  LoaderIcon,
  PipecatLogo,
  TranscriptOverlay,
  XIcon,
} from "@pipecat-ai/voice-ui-kit";
import { PlasmaVisualizer } from "@pipecat-ai/voice-ui-kit/webgl";
import { useEffect, useRef, useState } from "react";

export interface AppProps {
  connectParams: TransportConnectionParams | ConnectionEndpoint;
  transportType: "daily" | "smallwebrtc";
}

export type AppState = "idle" | "connecting" | "connected" | "disconnected";

export const App = ({ connectParams, transportType }: AppProps) => {
  const [client, setClient] = useState<PipecatClient | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [state, setState] = useState<AppState>("idle");
  const isMounted = useRef(false);

  useEffect(() => {
    if (isMounted.current) return;

    isMounted.current = true;
    async function initClient() {
      // Only run on client side
      if (typeof window === "undefined") return;

      let transport: DailyTransport | SmallWebRTCTransport;
      switch (transportType) {
        case "smallwebrtc":
          transport = new SmallWebRTCTransport();
          break;
        case "daily":
        default:
          transport = new DailyTransport();
          break;
      }

      const pcClient = new PipecatClient({
        enableCam: false,
        enableMic: true,
        transport: transport,
        callbacks: {
          onTransportStateChanged: (state: TransportState) => {
            switch (state) {
              case "connecting":
              case "authenticating":
              case "connected":
                setState("connecting");
                break;
              case "ready":
                setState("connected");
                break;
              case "disconnected":
              case "disconnecting":
              default:
                setState("idle");
                break;
            }
          },
          onError: () => {
            setError(
              "An error occured connecting to agent. It may be that the agent is at capacity. Please try again later.",
            );
          },
        },
      });
      await pcClient.initDevices();
      setClient(pcClient);
    }

    initClient();
  }, [connectParams, transportType]);

  const handleStartSession = async () => {
    if (
      !client ||
      !["initialized", "disconnected", "error"].includes(client.state)
    ) {
      return;
    }
    setError(null);

    try {
      await client.connect(connectParams);
    } catch (err) {
      console.error("Connection error:", err);
      setError(
        `Failed to start session: ${err instanceof Error ? err.message : String(err)}`,
      );
    }
  };

  if (!client) {
    return (
      <div className="w-full h-screen flex items-center justify-center">
        <LoaderIcon className="animate-spin opacity-50" size={32} />
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full h-screen flex items-center justify-center">
        <Card className="shadow-long">
          <CardContent>
            <div className="bg-destructive text-background font-semibold text-center p-3 rounded-lg flex flex-col gap-2">
              An error occured connecting to agent.
              <p className="text-sm font-medium text-balanced text-background/80">
                It may be that the agent is at capacity. Please try again later.
              </p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <PipecatClientProvider client={client!}>
      <div className="w-full h-screen">
        <div className="flex flex-col h-full">
          <div className="relative bg-background overflow-hidden flex-1 shadow-long/[0.02]">
            <main className="flex flex-col gap-0 h-full relative justify-end items-center">
              <PlasmaVisualizer state={state} />
              {["idle", "connecting"].includes(state) && (
                <div className="absolute w-full h-full flex items-center justify-center">
                  <ConnectButton size="xl" onConnect={handleStartSession} />
                </div>
              )}
              {state === "connected" && (
                <div className="absolute w-full h-full flex items-center justify-center">
                  <TranscriptOverlay
                    participant="remote"
                    className="vkui:max-w-md"
                  />
                </div>
              )}
              {state === "connected" && (
                <ControlBar onEndSession={() => client?.disconnect()} />
              )}
            </main>
          </div>
          <footer className="p-5 md:p-7 text-center flex flex-row gap-4 items-center justify-center">
            <PipecatLogo className="h-[24px] w-auto text-black" />
            <div className="flex flex-row gap-2 items-center justify-center opacity-60">
              <p className="text-sm text-muted-foreground font-medium">
                Pipecat AI
              </p>
              <XIcon size={16} className="text-black/30" />
              <p className="text-sm text-muted-foreground font-medium">
                Voice UI Kit
              </p>
            </div>
          </footer>
        </div>
      </div>
      <PipecatClientAudio />
    </PipecatClientProvider>
  );
};

export default App;



================================================
FILE: examples/03-app-helper/README.md
================================================
# Voice UI KIt - Console Template Example

This example shows how to implement the Console UI template.

It uses NextJS to demonstrate implementing a server-side route to handle bot start to protect API keys.

## Quickstart

Install node modules and chosen Pipecat client transport:

```shell
npm i 
npm i @pipecat-ai/small-webrtc-transport
# or
npm i @pipecat-ai/daily-transport
```

Create project `.env` file and set bot start endpoint and public API key (if relevant):

```shell
BOT_START_URL="https://..."
BOT_START_PUBLIC_API_KEY="abcxyz"
```

Run the application:

```shell
npm run dev
```


================================================
FILE: examples/03-app-helper/env.example
================================================
BOT_START_URL=""
BOT_START_PUBLIC_API_KEY=""


================================================
FILE: examples/03-app-helper/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: examples/03-app-helper/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {};

export default nextConfig;



================================================
FILE: examples/03-app-helper/package.json
================================================
{
  "name": "03-app-helper",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@pipecat-ai/voice-ui-kit": "file:../../",
    "next": "15.3.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tw-animate-css": "^1.3.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}



================================================
FILE: examples/03-app-helper/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: examples/03-app-helper/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: examples/03-app-helper/src/app/app.tsx
================================================
import { usePipecatClientTransportState } from "@pipecat-ai/client-react";
import {
  Button,
  ConnectButton,
  ControlBar,
  ControlBarDivider,
  HelperChildProps,
  LogoutIcon,
  TranscriptOverlay,
  UserAudioControl,
} from "@pipecat-ai/voice-ui-kit";
import { PlasmaVisualizer } from "@pipecat-ai/voice-ui-kit/webgl";

export const App = ({ handleConnect, handleDisconnect }: HelperChildProps) => {
  const transportState = usePipecatClientTransportState();
  return (
    <main className="relative flex flex-col gap-0 h-full w-full justify-end items-center">
      <PlasmaVisualizer />

      <div className="absolute inset-0 flex flex-col gap-4 items-center justify-center">
        <TranscriptOverlay participant="remote" className="max-w-md" />
      </div>

      {transportState === "ready" ? (
        <div className="relative z-10 h-1/2 flex flex-col w-full items-center justify-center">
          <ControlBar size="lg">
            <UserAudioControl size="xl" variant="outline" />
            <ControlBarDivider />
            <Button
              size="xl"
              isIcon={true}
              variant="outline"
              onClick={() => handleDisconnect?.()}
            >
              <LogoutIcon />
            </Button>
          </ControlBar>
        </div>
      ) : (
        <div className="absolute w-full h-full flex items-center justify-center">
          <ConnectButton size="xl" onConnect={() => handleConnect?.()} />
        </div>
      )}
    </main>
  );
};



================================================
FILE: examples/03-app-helper/src/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@import "@pipecat-ai/voice-ui-kit/styles";



================================================
FILE: examples/03-app-helper/src/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";

import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Voice UI Kit - App Helper Example",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



================================================
FILE: examples/03-app-helper/src/app/page.tsx
================================================
"use client";

import {
  AudioClientHelper,
  ErrorCard,
  FullScreenContainer,
  LoaderSpinner,
} from "@pipecat-ai/voice-ui-kit";

import { App } from "./app";

export default function Home() {
  return (
    <FullScreenContainer>
      <AudioClientHelper
        transportType="daily"
        connectParams={{
          endpoint: "/api/connect",
        }}
      >
        {({ handleConnect, handleDisconnect, loading, error }) =>
          loading ? (
            <LoaderSpinner />
          ) : error ? (
            <ErrorCard error={error} />
          ) : (
            <App
              handleConnect={handleConnect}
              handleDisconnect={handleDisconnect}
              error={error}
            />
          )
        }
      </AudioClientHelper>
    </FullScreenContainer>
  );
}



================================================
FILE: examples/03-app-helper/src/app/api/connect/route.ts
================================================
import { NextResponse } from "next/server";

export async function POST() {
  if (!process.env.BOT_START_URL) {
    return NextResponse.json(
      { error: "BOT_START_URL environment variable is not configured" },
      { status: 500 },
    );
  }

  try {
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    if (process.env.BOT_START_PUBLIC_API_KEY) {
      headers.Authorization = `Bearer ${process.env.BOT_START_PUBLIC_API_KEY}`;
    }

    const response = await fetch(process.env.BOT_START_URL, {
      method: "POST",
      mode: "cors",
      headers,
      body: JSON.stringify({
        createDailyRoom: true,
      }),
    });

    if (!response.ok) {
      let errorMessage = response.statusText;
      try {
        const errorData = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch {}

      return NextResponse.json(
        { error: errorMessage },
        { status: response.status },
      );
    }

    const data = await response.json();

    if (data.error) {
      return NextResponse.json({ error: data.error }, { status: 400 });
    }

    return NextResponse.json(
      {
        room_url: data.dailyRoom,
        token: data.dailyToken,
      },
      { status: 200 },
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return NextResponse.json(
      { error: `Failed to process connection request: ${errorMessage}` },
      { status: 500 },
    );
  }
}



================================================
FILE: src/icons.ts
================================================
import {
  ArrowDown,
  Bot,
  Check,
  ChevronDown,
  ChevronRight,
  ChevronsLeftRightEllipsis,
  ChevronsUpDown,
  ChevronUp,
  Circle,
  CircleAlert,
  Ellipsis,
  EllipsisVertical,
  Funnel,
  Info,
  LineChart,
  Loader2,
  LogOut,
  MessagesSquare,
  Mic,
  MicOff,
  Moon,
  PanelLeftClose,
  PanelRightClose,
  PhoneCall,
  PhoneOff,
  Send,
  Sun,
  Video,
  VideoOff,
  Volume2,
  VolumeOff,
  X,
} from "lucide-react";

export const VolumeIcon = Volume2;
export const VolumeOffIcon = VolumeOff;
export const EllipsisIcon = Ellipsis;
export const LoaderIcon = Loader2;
export const SelectChevronIcon = ChevronsUpDown;
export const XIcon = X;
export const PhoneCallIcon = PhoneCall;
export const PhoneCallEndIcon = PhoneOff;
export const ArrowDownIcon = ArrowDown;
export const ChevronDownIcon = ChevronDown;
export const ChevronUpIcon = ChevronUp;
export const MicIcon = Mic;
export const MicOffIcon = MicOff;
export const SendIcon = Send;
export const MoonIcon = Moon;
export const SunIcon = Sun;
export const CheckIcon = Check;
export const ChevronRightIcon = ChevronRight;
export const CircleIcon = Circle;
export const EllipsisVerticalIcon = EllipsisVertical;
export const VideoOffIcon = VideoOff;
export const LineChartIcon = LineChart;
export const MessagesSquareIcon = MessagesSquare;
export const FunnelIcon = Funnel;
export const VideoIcon = Video;
export const BotIcon = Bot;
export const ChevronsLeftRightEllipsisIcon = ChevronsLeftRightEllipsis;
export const InfoIcon = Info;
export const LogoutIcon = LogOut;
export const CircleAlertIcon = CircleAlert;
export const PanelRightCloseIcon = PanelRightClose;
export const PanelLeftCloseIcon = PanelLeftClose;



================================================
FILE: src/index.css
================================================
@import "tailwindcss" prefix(vkui);
@import "tw-animate-css" prefix(vkui);

@custom-variant dark (&:is(.vkui\:dark *));

@theme static {
  --font-sans: "Geist", "Inter", -apple-system, "Segoe UI", Roboto, sans-serif;
  --font-mono: "Geist Mono", "SF Mono", Consolas, "Roboto Mono", monospace;

  --shadow-long:
    0px 89px 36px rgba(0, 0, 0, 0.01), 0px 50px 30px rgba(0, 0, 0, 0.03),
    0px 22px 22px rgba(0, 0, 0, 0.04), 0px 6px 12px rgba(0, 0, 0, 0.05);
  --shadow-short:
    0px 10px 15px -3px rgba(0, 0, 0, 0.05), 0px 4px 6px -2px rgba(0, 0, 0, 0.02);
  --shadow-xshort:
    0px 7px 3px rgba(0, 0, 0, 0.01), 0px 4px 2px rgba(0, 0, 0, 0.03),
    0px 2px 2px rgba(0, 0, 0, 0.04), 0px 0px 1px rgba(0, 0, 0, 0.05);

  --radius-panel: var(--vkui-radius-sm);
  --radius-element: var(--vkui-radius-lg);

  --color-background: oklch(1 0 0);
  --color-foreground: oklch(0.141 0.005 285.823);
  --color-card: oklch(1 0 0);
  --color-card-foreground: oklch(55.2% 0.016 285.938);
  --color-popover: oklch(1 0 0);
  --color-popover-foreground: oklch(0.141 0.005 285.823);
  --color-primary: oklch(0.21 0.006 285.885);
  --color-primary-foreground: oklch(0.985 0 0);
  --color-secondary: oklch(0.967 0.001 286.375);
  --color-secondary-foreground: oklch(0.21 0.006 285.885);
  --color-muted: oklch(0.967 0.001 286.375);
  --color-muted-foreground: oklch(0.552 0.016 285.938);
  --color-accent: oklch(0.967 0.001 286.375);
  --color-accent-foreground: oklch(0.21 0.006 285.885);
  --color-destructive: oklch(63.7% 0.237 25.331);
  --color-border: oklch(0.92 0.004 286.32);
  --color-input: oklch(0.92 0.004 286.32);
  --color-ring: oklch(0.705 0.015 286.067);
  --color-subtle: oklch(0.705 0.015 286.067);
  --color-mute: oklch(63.7% 0.237 25.331);
  --color-mute-foreground: oklch(97% 0.05 25.331);

  /* VKUI */
  --color-active: oklch(69.6% 0.17 162.48);
  --color-active-foreground: oklch(97.9% 0.021 166.113);
  --color-active-ring: oklch(69.6% 0.17 162.48 / 20%);
  --color-active-accent: oklch(69.6% 0.17 162.48 / 10%);
  --color-inactive: oklch(0.7022 0.1892 22.23);
  --color-inactive-foreground: oklch(97.1% 0.013 17.38);
  --color-inactive-ring: oklch(57.7% 0.245 27.325 / 20%);
  --color-inactive-accent: oklch(57.7% 0.245 27.325 / 10%);
  --color-chart-1: oklch(0.646 0.222 41.116);
  --color-chart-2: oklch(0.6 0.118 184.704);
  --color-chart-3: oklch(0.398 0.07 227.392);
  --color-chart-4: oklch(0.828 0.189 84.429);
  --color-chart-5: oklch(0.769 0.188 70.08);

  --background-image-cardGradientBorder:
    linear-gradient(
      90deg,
      var(--vkui-color-background),
      var(--vkui-color-background)
    ),
    linear-gradient(
      0deg,
      color-mix(in oklch, var(--vkui-color-border) 92%, black),
      var(--vkui-color-border)
    );

  --background-clip-cardGradientBorder: padding-box, border-box;
}

.vkui\:dark {
  --vkui-color-background: oklch(0.141 0.005 285.823);
  --vkui-color-foreground: oklch(0.985 0 0);
  --vkui-color-card: oklch(0.21 0.006 285.885);
  --vkui-color-card-foreground: oklch(0.985 0 0);
  --vkui-color-popover: oklch(0.21 0.006 285.885);
  --vkui-color-popover-foreground: oklch(0.985 0 0);
  --vkui-color-primary: oklch(0.92 0.004 286.32);
  --vkui-color-primary-foreground: oklch(0.21 0.006 285.885);
  --vkui-color-secondary: oklch(0.274 0.006 286.033);
  --vkui-color-secondary-foreground: oklch(0.985 0 0);
  --vkui-color-muted: oklch(0.274 0.006 286.033);
  --vkui-color-muted-foreground: oklch(0.705 0.015 286.067);
  --vkui-color-accent: oklch(0.274 0.006 286.033);
  --vkui-color-accent-foreground: oklch(0.985 0 0);
  --vkui-color-destructive: oklch(57.7% 0.245 27.325);
  --vkui-color-border: oklch(1 0 0 / 10%);
  --vkui-color-input: oklch(1 0 0 / 15%);
  --vkui-color-ring: oklch(0.552 0.016 285.938);
  --vkui-color-subtle: oklch(44.2% 0.017 285.786);
  --vkui-color-mute: oklch(57.7% 0.245 27.325);
  --vkui-color-mute-foreground: oklch(97% 0.05 27.325);

  /* VKUI */
  --vkui-color-active: oklch(0.7019 0.15768 160.4375);
  --vkui-color-active-foreground: oklch(0.9793 0.0207 166.11);
  --vkui-color-active-ring: oklch(0.7019 0.15768 160.4375 / 40%);
  --vkui-color-active-accent: oklch(0.7019 0.15768 160.4375 / 20%);
  --vkui-color-inactive: oklch(0.7022 0.1892 22.23);
  --vkui-color-inactive-foreground: oklch(0.9705 0.0129 17.38);
  --vkui-color-inactive-ring: oklch(0.7022 0.1892 22.23 / 20%);
  --vkui-color-inactive-accent: oklch(0.7022 0.1892 22.23 / 10%);
  --vkui-color-chart-1: oklch(0.488 0.243 264.376);
  --vkui-color-chart-2: oklch(0.696 0.17 162.48);
  --vkui-color-chart-3: oklch(0.769 0.188 70.08);
  --vkui-color-chart-4: oklch(0.627 0.265 303.9);
  --vkui-color-chart-5: oklch(0.645 0.246 16.439);

  --vkui-background-image-cardGradientBorder:
    linear-gradient(
      90deg,
      var(--vkui-color-background),
      var(--vkui-color-background)
    ),
    linear-gradient(
      0deg,
      color-mix(in oklch, var(--vkui-color-border) 90%, white),
      var(--vkui-color-border)
    );
}

@layer base {
  * {
    border-color: var(--vkui-color-border);
    outline-color: color-mix(in oklab, var(--vkui-color-ring));
  }

  :root {
    color: var(--vkui-color-foreground);
    font-family: var(--vkui-font-sans);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}

@layer components {
  .vkui\:mono-upper {
    font-family: var(--vkui-font-mono);
    font-weight: var(--vkui-font-weight-bold);
    font-size: var(--vkui-text-xs);
    line-height: var(--tw-leading, var(--vkui-text-xs--line-height));
    letter-spacing: var(--vkui-tracking-wider);
    line-height: 1;
    text-transform: uppercase;
  }

  .vkui\:button-group.vkui\:flex-row > *:not(:first-child):not(:last-child) {
    border-radius: 0;
  }
  .vkui\:button-group.vkui\:flex-col > *:not(:first-child):not(:last-child) {
    border-radius: 0;
  }

  .vkui\:borderclip {
    background-clip: padding-box, border-box;
  }
}



================================================
FILE: src/index.ts
================================================
import "./index.css";

// UI
export * from "@/components/elements";
export * from "@/components/helpers";
export * from "@/components/panels";
export * from "@/components/ThemeModeToggle";
export * from "@/components/ThemeProvider";
export * from "@/components/ui";

export * from "@/hooks";
export * from "@/icons";

// Visualizers
export * from "@/visualizers";

// Templates
export { ConsoleTemplate } from "@/templates/Console";



================================================
FILE: src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: src/components/ThemeModeToggle.tsx
================================================
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTheme } from "@/hooks/useTheme";
import { MoonIcon, SunIcon } from "@/icons";

export function ThemeModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" isIcon>
          <SunIcon className="vkui:h-[1.2rem] vkui:w-[1.2rem] vkui:scale-100 vkui:rotate-0 vkui:transition-all vkui:dark:scale-0 vkui:dark:-rotate-90" />
          <MoonIcon className="vkui:absolute vkui:h-[1.2rem] vkui:w-[1.2rem] vkui:scale-0 vkui:rotate-90 vkui:transition-all vkui:dark:scale-100 vkui:dark:rotate-0" />
          <span className="vkui:sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export default ThemeModeToggle;



================================================
FILE: src/components/ThemeProvider.tsx
================================================
import { useEffect, useState } from "react";
import { ThemeProviderContext } from "./ThemeProviderContext";

export type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "voice-ui-kit-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(() => {
    // Initialize from localStorage or fall back to defaultTheme
    if (typeof window !== "undefined") {
      const storedTheme = localStorage.getItem(storageKey) as Theme;
      return storedTheme || defaultTheme;
    }
    return defaultTheme;
  });
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    if (!mounted) return;

    // Only store in localStorage if theme is not system, otherwise remove it
    if (theme !== "system") {
      localStorage.setItem(storageKey, theme);
    } else {
      localStorage.removeItem(storageKey);
    }
  }, [mounted, storageKey, theme]);

  useEffect(() => {
    if (!mounted) return;

    const root = window.document.documentElement;
    root.classList.remove("vkui:light", "vkui:dark");

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "vkui:dark"
        : "vkui:light";

      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(`vkui:${theme}`);
  }, [theme, mounted]);

  // Update theme when defaultTheme changes (if needed)
  useEffect(() => {
    if (!mounted) return;
    // Check if localStorage has a value before updating from defaultTheme
    const storedTheme = localStorage.getItem(storageKey);
    if (!storedTheme) {
      setTheme(defaultTheme);
    }
  }, [defaultTheme, mounted, storageKey]);

  const value = {
    theme,
    setTheme: (newTheme: Theme) => {
      setTheme(newTheme);
    },
    resolvedTheme:
      theme === "system"
        ? typeof window !== "undefined" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light"
        : theme,
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}



================================================
FILE: src/components/ThemeProviderContext.tsx
================================================
import { createContext } from "react";
import type { Theme } from "./ThemeProvider";

type ThemeProviderState = {
  resolvedTheme: "dark" | "light";
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
  resolvedTheme: "light",
  theme: "system",
  setTheme: () => null,
};

export const ThemeProviderContext =
  createContext<ThemeProviderState>(initialState);



================================================
FILE: src/components/elements/AudioOutput.tsx
================================================
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { usePipecatClientMediaDevices } from "@pipecat-ai/client-react";
import React, { useId } from "react";

interface AudioOutputProps {
  className?: string;
}

export const AudioOutput: React.FC<AudioOutputProps> = ({ className }) => {
  const { availableSpeakers, selectedSpeaker, updateSpeaker } =
    usePipecatClientMediaDevices();

  const handleDeviceChange = (deviceId: string) => {
    updateSpeaker(deviceId);
  };

  const id = useId();

  return (
    <div className="vkui:flex vkui:items-center vkui:gap-4">
      <label
        htmlFor={id}
        className="vkui:text-sm vkui:font-medium vkui:text-muted-foreground vkui:whitespace-nowrap vkui:flex-1"
      >
        Audio Output
      </label>
      <Select
        value={selectedSpeaker?.deviceId || ""}
        onValueChange={handleDeviceChange}
      >
        <SelectTrigger id={id} className={className} variant="ghost">
          <SelectValue placeholder="Select a speaker" />
        </SelectTrigger>
        <SelectContent align="end">
          {availableSpeakers.map((device) => (
            <SelectItem
              key={device.deviceId || "empty"}
              value={device.deviceId || "empty"}
            >
              {device.label || `Speaker ${device.deviceId.slice(0, 5)}`}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default AudioOutput;



================================================
FILE: src/components/elements/ClientStatus.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import { type TransportState, TransportStateEnum } from "@pipecat-ai/client-js";
import { ClientStatusComponent } from "./ClientStatus";

const transportStateOptions = Object.values(TransportStateEnum);

export default {
  title: "Components / Client Status",
  args: {
    state: "disconnected",
  },
  argTypes: {
    transportState: {
      options: transportStateOptions,
      control: { type: "select" },
      defaultValue: "disconnected",
    },
  },
} satisfies StoryDefault;

export const Default: Story<{ transportState: TransportState }> = ({
  transportState,
}) => <ClientStatusComponent transportState={transportState} />;

Default.storyName = "Default";



================================================
FILE: src/components/elements/ClientStatus.tsx
================================================
import DataList from "@/components/elements/DataList";
import { LoaderIcon } from "@/icons";
import { TextDashBlankslate } from "@/index";
import { cn } from "@/lib/utils";
import { RTVIEvent } from "@pipecat-ai/client-js";
import {
  usePipecatClientTransportState,
  useRTVIClientEvent,
} from "@pipecat-ai/client-react";
import { useEffect, useState } from "react";

interface Props {
  classNames?: React.ComponentProps<typeof DataList>["classNames"] & {
    agentValue?: string;
    clientValue?: string;
  };
  noAgentState?: boolean;
  noClientState?: boolean;
}

export const ClientStatusComponent = ({
  className,
  transportState,
}: {
  className?: string;
  transportState?: string | null;
}) => {
  return (
    <span
      className={cn(
        "vkui:mono-upper vkui:text-muted-foreground vkui:font-medium vkui:flex vkui:items-center vkui:gap-1.5 vkui:leading-none vkui:justify-end",
        {
          "vkui:text-active":
            transportState === "connected" || transportState === "ready",
          "vkui:text-destructive": transportState === "error",
          "vkui:text-subtle/50 vkui:dark:text-subtle/80":
            transportState === "disconnected",
          "vkui:text-subtle": !transportState,
          "vkui:animate-pulse": [
            "initializing",
            "authenticating",
            "authenticated",
            "connecting",
          ].includes(transportState || ""),
        },
        className,
      )}
    >
      {transportState || <TextDashBlankslate />}
      {transportState &&
        ["authenticating", "authenticated", "connecting"].includes(
          transportState,
        ) && <LoaderIcon size={12} className="vkui:animate-spin" />}
    </span>
  );
};

export const ClientStatus: React.FC<Props> = ({
  classNames = {},
  noAgentState = false,
  noClientState = false,
}) => {
  const transportState = usePipecatClientTransportState();

  const [botStatus, setBotStatus] = useState<
    "disconnected" | "connecting" | "connected" | "ready" | null
  >(null);

  useEffect(() => {
    if (transportState === "connecting") {
      setBotStatus("connecting");
    }
  }, [transportState]);

  useRTVIClientEvent(RTVIEvent.BotReady, () => {
    if (noAgentState) return;
    setBotStatus("ready");
  });
  useRTVIClientEvent(RTVIEvent.BotConnected, () => {
    if (noAgentState) return;
    setBotStatus("connected");
  });
  useRTVIClientEvent(RTVIEvent.Disconnected, () => {
    if (noAgentState) return;
    setBotStatus("disconnected");
  });
  useRTVIClientEvent(RTVIEvent.BotDisconnected, () => {
    if (noAgentState) return;
    setBotStatus("disconnected");
  });

  if (noAgentState && noClientState) return null;

  const data: React.ComponentProps<typeof DataList>["data"] = {};
  if (!noClientState) {
    data["Client"] = <ClientStatusComponent transportState={transportState} />;
  }

  if (!noAgentState) {
    data["Agent"] = <ClientStatusComponent transportState={botStatus} />;
  }

  return <DataList classNames={classNames} data={data} />;
};

export default ClientStatus;



================================================
FILE: src/components/elements/ConnectButton.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import { type TransportState, TransportStateEnum } from "@pipecat-ai/client-js";
import { type ButtonSize, buttonSizeOptions } from "../ui/buttonVariants";
import { ConnectButtonComponent } from "./ConnectButton";

const transportStateOptions = Object.values(TransportStateEnum);

export default {
  title: "Components / Connect Button",
  argTypes: {
    transportState: {
      options: transportStateOptions,
      control: { type: "select" },
      defaultValue: "disconnected",
    },
    size: {
      options: buttonSizeOptions,
      control: { type: "select" },
      defaultValue: "default",
    },
  },
} satisfies StoryDefault;

export const ConnectButtonDefault: Story<{
  transportState: TransportState;
  size: ButtonSize;
}> = ({ transportState, size }) => {
  return <ConnectButtonComponent transportState={transportState} size={size} />;
};
ConnectButtonDefault.storyName = "Default";



================================================
FILE: src/components/elements/ConnectButton.tsx
================================================
import { Button } from "@/components/ui/button";
import type { ButtonSize, ButtonVariant } from "@/components/ui/buttonVariants";
import { cn } from "@/lib/utils";
import { type TransportState } from "@pipecat-ai/client-js";
import { usePipecatClientTransportState } from "@pipecat-ai/client-react";
import React, { memo } from "react";

/**
 * Configuration for customizing button appearance and content for specific transport states.
 * Allows partial configuration - only specify the states you want to customize.
 */
export type ConnectButtonStateContent = Partial<
  Record<
    TransportState,
    {
      /** The text or content to display in the button */
      children: React.ReactNode;
      /** The button variant to use for this state */
      variant: ButtonVariant;
      /** Optional CSS class to apply to the button */
      className?: string;
    }
  >
>;

/**
 * Props for the ConnectButton component.
 */
export type ConnectButtonProps = {
  /** CSS class name to apply to the button */
  className?: string;
  /** Callback function called when the connect action is triggered */
  onConnect?: () => void;
  /** Generic click handler for the button */
  onClick?: () => void;
  /** Callback function called when the disconnect action is triggered */
  onDisconnect?: () => void;
  /** Size of the button component */
  size?: ButtonSize;
  /** Default variant of the button component */
  defaultVariant?: ButtonVariant;
  /** Custom state content configuration for different transport states */
  stateContent?: ConnectButtonStateContent;
};

/**
 * Internal component that renders a connect/disconnect button based on transport state.
 * Handles button appearance, content, and interactions based on the current transport state.
 *
 * @param props - Component props including transport state and configuration
 * @returns A button component that adapts to the current transport state
 */
export const ConnectButtonComponent: React.FC<
  ConnectButtonProps & {
    transportState: TransportState;
  }
> = ({
  className: passedClassName,
  onClick,
  onConnect,
  onDisconnect,
  stateContent,
  size = "default",
  transportState,
}) => {
  /**
   * Determines button properties based on current transport state and custom state content.
   * Prioritizes custom state content over default behavior.
   *
   * @returns Button props including children, variant, and className
   */
  const getButtonProps = (): React.ComponentProps<typeof Button> => {
    // Check if we have custom content for this state
    if (stateContent && stateContent[transportState]) {
      return stateContent[transportState]!;
    }

    // Default content based on transport state
    switch (transportState) {
      case "disconnected":
      case "initialized":
        return {
          children: "Connect",
          variant: "active",
        };
      case "initializing":
        return {
          children: "Initializing...",
          variant: "secondary",
        };
      case "ready":
        return {
          children: "Disconnect",
          variant: "destructive",
        };
      case "disconnecting":
        return { children: "Disconnecting...", variant: "secondary" };
      case "error":
        return { children: "Error", variant: "destructive" };
      default:
        return { children: "Connecting...", variant: "secondary" };
    }
  };

  const { children, className, variant } = getButtonProps();

  /**
   * Handles button click events.
   * Calls the generic onClick handler, then either onConnect or onDisconnect based on current state.
   */
  const handleClick = () => {
    onClick?.();
    if (["ready", "connected"].includes(transportState)) {
      onDisconnect?.();
    } else {
      onConnect?.();
    }
  };

  return (
    <Button
      onClick={handleClick}
      variant={variant}
      size={size}
      disabled={
        !["disconnected", "ready", "initialized"].includes(transportState)
      }
      isLoading={
        !["disconnected", "ready", "error", "initialized"].includes(
          transportState,
        )
      }
      className={cn(className, passedClassName)}
    >
      {children}
    </Button>
  );
};

/**
 * ConnectButton component that automatically adapts to the current transport state.
 *
 * This component:
 * - Automatically gets the current transport state from the Pipecat client
 * - Renders a button that changes appearance and behavior based on the state
 * - Handles connect/disconnect actions automatically
 * - Supports custom state content configuration
 *
 * @param props - Component configuration including callbacks and styling options
 * @returns A button component that adapts to transport state changes
 */
export const ConnectButton = memo((props: ConnectButtonProps) => {
  const transportState = usePipecatClientTransportState();

  return <ConnectButtonComponent transportState={transportState} {...props} />;
});

ConnectButton.displayName = "ConnectButton";

export default ConnectButton;



================================================
FILE: src/components/elements/ControlBar.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import { type CardProps, FullScreenContainer } from "../ui";
import { ControlBar, ControlBarDivider } from "./ControlBar";

export default {
  title: "Components / Control Bar",
  args: {
    noGradientBorder: false,
    noShadow: false,
    size: "default",
  },
} satisfies StoryDefault;

export const Default: Story = ({ ...props }: CardProps) => (
  <FullScreenContainer>
    <ControlBar {...props}>
      aa
      <ControlBarDivider />
      bb
    </ControlBar>
  </FullScreenContainer>
);

Default.storyName = "Default";



================================================
FILE: src/components/elements/ControlBar.tsx
================================================
import { Card, CardContent, type CardProps } from "@/components/ui";
import { cn } from "@/lib/utils";

interface Props extends CardProps {
  children?: React.ReactNode;
  className?: string;
  noAnimateIn?: boolean;
}

export const ControlBarDivider = ({
  className,
}: React.ComponentProps<"div">) => {
  return (
    <div
      className={cn(
        "vkui:w-px vkui:bg-border vkui:self-stretch vkui:mx-2 ",
        className,
      )}
    />
  );
};

export const ControlBar = ({
  children,
  noAnimateIn = false,
  className,
  ...props
}: Props) => {
  return (
    <Card
      className={cn(
        !noAnimateIn &&
          "vkui:animate-in vkui:fade-in vkui:slide-in-from-bottom-10 vkui:duration-500",
        className,
      )}
      {...props}
    >
      <CardContent className="vkui:flex vkui:flex-row vkui:gap-4 vkui:p-4">
        {children}
      </CardContent>
    </Card>
  );
};



================================================
FILE: src/components/elements/Conversation.tsx
================================================
import Thinking from "@/components/elements/Thinking";
import useConversation from "@/hooks/useConversation";
import { cn } from "@/lib/utils";
import { usePipecatClientTransportState } from "@pipecat-ai/client-react";
import { Fragment, useCallback, useEffect, useRef } from "react";

interface Props {
  classNames?: {
    container?: string;
    message?: string;
    messageContent?: string;
    role?: string;
    time?: string;
    thinking?: string;
  };
  noAutoscroll?: boolean;
}

export const Conversation: React.FC<Props> = ({
  classNames = {},
  noAutoscroll = false,
}) => {
  const scrollRef = useRef<HTMLDivElement>(null);
  const isScrolledToBottom = useRef(true);

  const transportState = usePipecatClientTransportState();

  const maybeScrollToBottom = useCallback(() => {
    if (!scrollRef.current) return;
    if (isScrolledToBottom.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: "smooth",
      });
    }
  }, []);

  // Check scroll position before messages update
  const updateScrollState = useCallback(() => {
    if (!scrollRef.current || noAutoscroll) return;
    isScrolledToBottom.current =
      Math.ceil(scrollRef.current.scrollHeight - scrollRef.current.scrollTop) <=
      Math.ceil(scrollRef.current.clientHeight);
  }, [noAutoscroll]);

  const { messages } = useConversation({
    onMessageAdded: () => {
      if (noAutoscroll) return;
      maybeScrollToBottom();
    },
  });

  useEffect(() => {
    if (noAutoscroll) return;
    // Scroll to bottom when messages change
    maybeScrollToBottom();
  }, [messages, maybeScrollToBottom, noAutoscroll]);

  // Update scroll state when user scrolls
  useEffect(() => {
    const scrollElement = scrollRef.current;
    if (!scrollElement) return;

    const handleScroll = () => updateScrollState();
    scrollElement.addEventListener("scroll", handleScroll);

    // Initial check
    updateScrollState();

    return () => scrollElement.removeEventListener("scroll", handleScroll);
  }, [updateScrollState]);

  const isConnecting =
    transportState === "authenticating" || transportState === "connecting";
  const isConnected =
    transportState === "connected" || transportState === "ready";

  if (messages.length > 0) {
    return (
      <div
        ref={scrollRef}
        className={cn(
          "vkui:h-full vkui:overflow-y-auto vkui:p-4",
          classNames.container,
        )}
      >
        <div
          className={cn(
            "vkui:grid vkui:grid-cols-[min-content_1fr] vkui:gap-x-4 vkui:gap-y-2",
            classNames.message,
          )}
        >
          {messages.map((message, index) => (
            <Fragment key={index}>
              <div
                className={cn(
                  "vkui:font-semibold vkui:font-mono vkui:text-xs vkui:leading-6",
                  {
                    "vkui:text-blue-500": message.role === "user",
                    "vkui:text-purple-500": message.role === "assistant",
                  },
                  classNames.role,
                )}
              >
                {message.role}
              </div>
              <div
                className={cn(
                  "vkui:flex vkui:flex-col vkui:gap-2",
                  classNames.messageContent,
                )}
              >
                {message.content || (
                  <Thinking className={classNames.thinking} />
                )}
                <div
                  className={cn(
                    "vkui:self-end vkui:text-xs vkui:text-gray-500 vkui:mb-1",
                    classNames.time,
                  )}
                >
                  {new Date(message.createdAt).toLocaleTimeString()}
                </div>
              </div>
            </Fragment>
          ))}
        </div>
      </div>
    );
  }

  if (isConnecting) {
    return (
      <div
        className={cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
          classNames.container,
        )}
      >
        <div className="vkui:text-muted-foreground vkui:text-sm">
          Connecting to agent...
        </div>
      </div>
    );
  }

  if (!isConnected) {
    return (
      <div
        className={cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
          classNames.container,
        )}
      >
        <div className="vkui:text-center vkui:p-4">
          <div className="vkui:text-muted-foreground vkui:mb-2">
            Not connected to agent
          </div>
          <p className="vkui:text-sm vkui:text-muted-foreground vkui:max-w-md">
            Connect to an agent to see conversation messages in real-time.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div
      className={cn(
        "vkui:flex vkui:items-center vkui:justify-center vkui:h-full",
        classNames.container,
      )}
    >
      <div className="vkui:text-muted-foreground vkui:text-sm">
        Waiting for messages...
      </div>
    </div>
  );
};
export default Conversation;



================================================
FILE: src/components/elements/CopyText.tsx
================================================
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import { CopyCheckIcon, CopyIcon } from "lucide-react";
import React, { useState } from "react";

interface CopyTextProps {
  className?: string;
  iconSize?: number;
  text: string;
}

export const CopyText: React.FC<CopyTextProps> = ({
  text,
  iconSize = 16,
  className = "",
}) => {
  const [copied, setCopied] = useState(false);

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy text: ", err);
    }
  };

  return (
    <div
      className={cn(
        "vkui:flex vkui:items-center vkui:overflow-hidden vkui:w-full",
        className,
      )}
    >
      <span className="vkui:truncate vkui:min-w-0">{text}</span>
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="ghost"
              isIcon
              size="sm"
              className="vkui:flex-none vkui:text-muted-foreground"
              onClick={copyToClipboard}
              aria-label="Copy to clipboard"
            >
              {copied ? (
                <CopyCheckIcon size={iconSize} />
              ) : (
                <CopyIcon size={iconSize} />
              )}
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            {copied ? "Copied!" : "Copy to clipboard"}
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
};

export default CopyText;



================================================
FILE: src/components/elements/DataList.tsx
================================================
import React, { type ReactNode } from "react";
import { cn } from "../../lib/utils";

interface DataListProps {
  data: Record<string, string | ReactNode>;
  classNames?: {
    container?: string;
    key?: string;
    value?: string;
  };
}

export const DataList: React.FC<DataListProps> = ({
  data,
  classNames = {},
}) => {
  return (
    <dl
      className={cn(
        "vkui:text-sm vkui:grid vkui:grid-cols-[1fr_2fr] vkui:gap-2 vkui:items-center",
        classNames.container,
      )}
    >
      {Object.entries(data).map(([key, value]) => (
        <React.Fragment key={key}>
          <dt className={cn("vkui:text-muted-foreground", classNames.key)}>
            {key}
          </dt>
          <dd
            className={cn(
              "vkui:text-right vkui:font-mono vkui:text-xs vkui:min-w-0 vkui:truncate",
              classNames.value,
            )}
          >
            {value}
          </dd>
        </React.Fragment>
      ))}
    </dl>
  );
};

export default DataList;



================================================
FILE: src/components/elements/DeviceDropDown.tsx
================================================
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { type OptionalMediaDeviceInfo } from "@pipecat-ai/client-react";

export interface DeviceDropDownProps {
  children: React.ReactNode;
  noMenuLabel?: boolean;
  noMenuSeparator?: boolean;
  menuLabel?: string;
  availableDevices?: MediaDeviceInfo[];
  selectedDevice?: OptionalMediaDeviceInfo;
  updateDevice?: (deviceId: string) => void;
  classNames?: {
    dropdownMenuTrigger?: string;
    dropdownMenuContent?: string;
    dropdownMenuCheckboxItem?: string;
  };
}

export const DeviceDropDown = ({
  children,
  noMenuLabel = false,
  noMenuSeparator = false,
  menuLabel = "Device select",
  availableDevices,
  selectedDevice,
  updateDevice,
  classNames,
}: DeviceDropDownProps) => {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>{children}</DropdownMenuTrigger>
      <DropdownMenuContent
        align="end"
        className={cn(classNames?.dropdownMenuContent)}
      >
        {!noMenuLabel && <DropdownMenuLabel>{menuLabel}</DropdownMenuLabel>}
        {!noMenuSeparator && <DropdownMenuSeparator />}
        {availableDevices?.map((device) => (
          <DropdownMenuCheckboxItem
            key={device.deviceId}
            checked={selectedDevice?.deviceId === device.deviceId}
            onCheckedChange={() => updateDevice?.(device.deviceId)}
            className={cn(classNames?.dropdownMenuCheckboxItem)}
          >
            {device.label || `Device ${device.deviceId.slice(0, 5)}`}
          </DropdownMenuCheckboxItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};



================================================
FILE: src/components/elements/index.ts
================================================
export * from "./AudioOutput";
export * from "./ClientStatus";
export * from "./ConnectButton";
export * from "./ControlBar";
export * from "./Conversation";
export * from "./CopyText";
export * from "./DataList";
export * from "./PipecatLogo";
export * from "./SessionInfo";
export * from "./Thinking";
export * from "./TranscriptOverlay";
export * from "./UserAudioControl";
export * from "./UserVideoControl";



================================================
FILE: src/components/elements/PipecatLogo.tsx
================================================
import React from "react";

interface PipecatLogoProps {
  alt?: string;
  className?: string;
  color?: string;
  height?: number;
  width?: number;
}

const aspectRatio = 45 / 26;

export const PipecatLogo: React.FC<PipecatLogoProps> = ({
  className = "",
  alt = "Pipecat Logo",
  color = "currentColor",
  height,
  width,
}) => {
  const resolvedHeight = height
    ? height
    : width
      ? Math.round(width / aspectRatio)
      : 100;
  const resolvedWidth = width
    ? width
    : height
      ? Math.round(height * aspectRatio)
      : 200;

  return (
    <svg
      width={resolvedWidth}
      height={resolvedHeight}
      viewBox="0 0 45 26"
      xmlns="http://www.w3.org/2000/svg"
      className={className}
      aria-label={alt}
    >
      <path
        d="M6.19825 0.104287C6.83144 -0.13411 7.5461 0.044779 7.99232 0.553371L13.8037 7.17714H31.1545L36.9659 0.553371C37.4121 0.044779 38.1268 -0.13411 38.76 0.104287C39.3932 0.342685 39.8124 0.948477 39.8124 1.62507V16.25H44.9582V19.5H36.5624V5.94116L33.112 9.87383C32.8035 10.2255 32.3584 10.4271 31.8905 10.4271H13.0677C12.5998 10.4271 12.1547 10.2255 11.8462 9.87383L8.39581 5.94116V19.5H0V16.25H5.14582V1.62507C5.14582 0.948477 5.56505 0.342685 6.19825 0.104287Z"
        fill={color}
      />
      <path d="M36.5624 22.75H44.9582V26H36.5624V22.75Z" fill={color} />
      <path d="M0 22.75H8.39581V26H0V22.75Z" fill={color} />
      <path
        d="M17.3333 17.3334C17.3333 18.53 16.3632 19.5 15.1666 19.5C13.97 19.5 13 18.53 13 17.3334C13 16.1367 13.97 15.1667 15.1666 15.1667C16.3632 15.1667 17.3333 16.1367 17.3333 17.3334Z"
        fill={color}
      />
      <path
        d="M31.9582 17.3334C31.9582 18.53 30.9882 19.5 29.7916 19.5C28.595 19.5 27.6249 18.53 27.6249 17.3334C27.6249 16.1367 28.595 15.1667 29.7916 15.1667C30.9882 15.1667 31.9582 16.1367 31.9582 17.3334Z"
        fill={color}
      />
    </svg>
  );
};

export default PipecatLogo;



================================================
FILE: src/components/elements/SessionInfo.tsx
================================================
import CopyText from "@/components/elements/CopyText";
import DataList from "@/components/elements/DataList";
import { TextDashBlankslate } from "@/index";
import Daily from "@daily-co/daily-js";
import { usePipecatClient } from "@pipecat-ai/client-react";

interface Props {
  noTransportType?: boolean;
  noSessionId?: boolean;
  noParticipantId?: boolean;
  noRTVIVersion?: boolean;
  participantId?: string;
  sessionId?: string;
}

export const SessionInfo: React.FC<Props> = ({
  noTransportType = false,
  noSessionId = false,
  noParticipantId = false,
  noRTVIVersion = false,
  sessionId,
  participantId,
}) => {
  const client = usePipecatClient();

  let transportTypeName = "Unknown";
  if (client && "dailyCallClient" in client.transport) {
    transportTypeName = `Daily (v${Daily.version()})`;
  } else if (
    // @ts-expect-error - __proto__ not typed
    client?.transport.__proto__.constructor.SERVICE_NAME ===
    "small-webrtc-transport"
  ) {
    transportTypeName = "Small WebRTC";
  }

  const data: React.ComponentProps<typeof DataList>["data"] = {};
  if (!noTransportType) {
    data["Transport"] = transportTypeName;
  }
  if (!noSessionId) {
    data["Session ID"] = sessionId ? (
      <CopyText className="vkui:justify-end" iconSize={12} text={sessionId} />
    ) : (
      <TextDashBlankslate />
    );
  }
  if (!noParticipantId) {
    data["Participant ID"] = participantId ? (
      <CopyText
        className="vkui:justify-end"
        iconSize={12}
        text={participantId}
      />
    ) : (
      <TextDashBlankslate />
    );
  }
  if (!noRTVIVersion) {
    data["RTVI"] = client?.version || <TextDashBlankslate />;
  }

  return (
    <DataList
      classNames={{ container: "vkui:w-full vkui:overflow-hidden" }}
      data={data}
    />
  );
};



================================================
FILE: src/components/elements/Thinking.tsx
================================================
import React, { useEffect, useState } from "react";

interface ThinkingProps {
  "aria-label"?: string;
  className?: string;
  initialDots?: number;
  interval?: number;
  maxDots?: number;
}

export const Thinking: React.FC<ThinkingProps> = ({
  "aria-label": ariaLabel = "Loading",
  className = "",
  initialDots = 1,
  interval = 500,
  maxDots = 3,
}) => {
  const [dots, setDots] = useState(initialDots);

  useEffect(() => {
    const i = setInterval(() => {
      setDots((prevDots) => (prevDots % maxDots) + 1);
    }, interval);

    return () => clearInterval(i);
  }, [interval, maxDots]);

  const renderDots = () => {
    return ".".repeat(dots);
  };

  return (
    <span className={className} aria-label={ariaLabel}>
      {renderDots()}
    </span>
  );
};

export default Thinking;



================================================
FILE: src/components/elements/TranscriptOverlay.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import {
  TranscriptOverlayComponent,
  TranscriptOverlayPartComponent,
} from "./TranscriptOverlay";

export default {
  title: "Components / Transcript Overlay",
  args: {
    size: "default",
  },
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["default", "sm", "lg"],
      defaultValue: "default",
    },
  },
} satisfies StoryDefault;

export const TextPart: Story<{ size: "default" | "sm" | "lg" }> = ({
  size,
}) => (
  <TranscriptOverlayComponent size={size} className="vkui:max-w-md">
    <TranscriptOverlayPartComponent text="Hello my name is ChatBot. How are you today? Would you like to talk about the weather?" />
  </TranscriptOverlayComponent>
);

TextPart.storyName = "Text Part";



================================================
FILE: src/components/elements/TranscriptOverlay.tsx
================================================
"use client";

import { cn } from "@/lib/utils";
import { type BotTTSTextData, RTVIEvent } from "@pipecat-ai/client-js";
import {
  usePipecatClientTransportState,
  useRTVIClientEvent,
} from "@pipecat-ai/client-react";
import { cva } from "class-variance-authority";
import { useCallback, useState } from "react";

interface Props {
  participant: "local" | "remote";
  className?: string;
  size?: "default";
}

const transcriptOverlayVariants = cva(
  `vkui:mx-auto vkui:items-center vkui:justify-end vkui:text-center 
  vkui:*:box-decoration-clone vkui:*:text-balance vkui:*:animate-in vkui:*:fade-in vkui:*:duration-300 vkui:*:mx-auto
  vkui:*:**:bg-foreground vkui:*:**:text-background vkui:*:**:box-decoration-clone vkui:*:**:text-balance
  `,
  {
    variants: {
      size: {
        default:
          "vkui:*:leading-6 vkui:*:**:px-3 vkui:*:**:py-1.5 vkui:*:**:text-sm vkui:*:**:font-medium vkui:*:**:rounded-lg",
        sm: "vkui:*:leading-4 vkui:*:**:px-2 vkui:*:**:py-1 vkui:*:**:text-xs vkui:*:**:font-medium vkui:*:**:rounded-md",
        lg: "vkui:*:leading-7 vkui:*:**:px-4 vkui:*:**:py-2 vkui:*:**:text-base vkui:*:**:font-medium vkui:*:**:rounded-xl",
      },
    },
  },
);

export const TranscriptOverlayPartComponent = ({ text }: { text: string }) => (
  <span>{text}</span>
);

export const TranscriptOverlayComponent = ({
  children,
  className,
  size = "default",
  turnEnd,
}: {
  children: React.ReactNode;
  className?: string;
  size?: "default" | "sm" | "lg";
  turnEnd?: boolean;
}) => {
  return (
    <div
      className={cn(
        transcriptOverlayVariants({ size }),
        turnEnd
          ? "vkui:animate-out vkui:fade-out vkui:duration-1000 vkui:fill-mode-forwards"
          : "",
        className,
      )}
    >
      <p>{children}</p>
    </div>
  );
};

export const TranscriptOverlay = ({
  participant = "remote",
  className,
  size = "default",
}: Props) => {
  const [transcript, setTranscript] = useState<string[]>([]);
  const [turnEnd, setIsTurnEnd] = useState(false);
  const transportState = usePipecatClientTransportState();

  useRTVIClientEvent(
    RTVIEvent.BotTtsText,
    useCallback(
      (event: BotTTSTextData) => {
        if (participant === "local") {
          return;
        }

        if (turnEnd) {
          setTranscript([]);
          setIsTurnEnd(false);
        }

        setTranscript((prev) => [...prev, event.text]);
      },
      [turnEnd, participant],
    ),
  );

  useRTVIClientEvent(
    RTVIEvent.BotStoppedSpeaking,
    useCallback(() => {
      if (participant === "local") {
        return;
      }
      setIsTurnEnd(true);
    }, [participant]),
  );

  useRTVIClientEvent(
    RTVIEvent.BotTtsStopped,
    useCallback(() => {
      if (participant === "local") {
        return;
      }
      setIsTurnEnd(true);
    }, [participant]),
  );

  if (transcript.length === 0 || transportState !== "ready") {
    return null;
  }

  return (
    <TranscriptOverlayComponent
      size={size}
      turnEnd={turnEnd}
      className={className}
    >
      <TranscriptOverlayPartComponent text={transcript.join(" ")} />
    </TranscriptOverlayComponent>
  );
};

export default TranscriptOverlay;



================================================
FILE: src/components/elements/UserAudioControl.stories.tsx
================================================
import type {
  ButtonSize,
  ButtonState,
  ButtonVariant,
} from "@/components/ui/buttonVariants";
import {
  buttonSizeOptions,
  buttonVariantOptions,
} from "@/components/ui/buttonVariants";
import type { Story, StoryDefault } from "@ladle/react";
import { PipecatClient } from "@pipecat-ai/client-js";
import {
  type OptionalMediaDeviceInfo,
  PipecatClientProvider,
} from "@pipecat-ai/client-react";
import { SmallWebRTCTransport } from "@pipecat-ai/small-webrtc-transport";
import { useEffect, useState } from "react";
import UserAudioControl, { UserAudioComponent } from "./UserAudioControl";

export default {
  title: "Components / User Audio Control",
  argTypes: {
    variant: {
      options: buttonVariantOptions,
      control: { type: "select" },
      defaultValue: "secondary",
    },
    size: {
      options: buttonSizeOptions,
      control: { type: "select" },
      defaultValue: "default",
    },
    noAudioText: {
      control: { type: "text" },
      defaultValue: null,
    },
  },
} satisfies StoryDefault;

/**
 * No audio / audio disabled
 */
export const NoAudio: Story<{
  variant: ButtonVariant;
  size: ButtonSize;
  noAudioText: string;
}> = ({ variant, size, noAudioText }) => {
  return (
    <UserAudioComponent
      variant={variant}
      size={size}
      noAudio={true}
      {...(noAudioText && { noAudioText })}
    />
  );
};

NoAudio.args = {
  variant: "secondary",
  size: "default",
};

NoAudio.storyName = "No Audio";

/**
 * Active
 */
export const Default: Story<{
  variant: ButtonVariant;
  size: ButtonSize;
  isMuted: boolean;
  noDevicePicker: boolean;
  noVisualizer: boolean;
  isLoading: boolean;
}> = ({
  variant,
  size,
  isMuted = false,
  noDevicePicker = false,
  noVisualizer = false,
  isLoading = false,
}) => (
  <UserAudioComponent
    variant={variant}
    size={size}
    isMicEnabled={!isMuted}
    availableMics={[]}
    selectedMic={undefined as unknown as OptionalMediaDeviceInfo}
    updateMic={() => {}}
    noVisualizer={noVisualizer}
    noDevicePicker={noDevicePicker}
    buttonProps={{
      isLoading,
    }}
  />
);

Default.args = {
  variant: "secondary",
  size: "default",
  isMuted: false,
};

Default.argTypes = {
  ...Default.argTypes,
  isMuted: {
    control: { type: "boolean" },
    defaultValue: false,
  },
  noDevicePicker: {
    control: { type: "boolean" },
    defaultValue: false,
  },
  noVisualizer: {
    control: { type: "boolean" },
    defaultValue: false,
  },
  isLoading: {
    control: { type: "boolean" },
    defaultValue: false,
  },
};

Default.storyName = "Default";

/**
 * Connected
 */
export const Connected: Story<{
  variant: ButtonVariant;
  size: ButtonSize;
  state: ButtonState;
}> = ({ variant, size, state }) => (
  <UserAudioControl variant={variant} size={size} state={state} />
);

Connected.args = {
  variant: "secondary",
  size: "default",
};

Connected.decorators = [
  (Component) => {
    const [client, setClient] = useState<PipecatClient | null>(null);

    useEffect(() => {
      const client = new PipecatClient({
        transport: new SmallWebRTCTransport(),
      });
      setClient(client);
    }, []);

    if (!client) {
      return <div>Loading...</div>;
    }

    return (
      <div>
        <PipecatClientProvider client={client!}>
          <Component />
        </PipecatClientProvider>
      </div>
    );
  },
];
Connected.storyName = "Connected";



================================================
FILE: src/components/elements/UserAudioControl.tsx
================================================
"use client";

import { Button } from "@/components/ui/button";
import { ButtonGroup } from "@/components/ui/buttongroup";
import {
  buttonAccentColorMap,
  type ButtonSize,
  type ButtonState,
  type ButtonVariant,
} from "@/components/ui/buttonVariants";
import { ChevronDownIcon, MicIcon, MicOffIcon } from "@/icons";
import { cn } from "@/lib/utils";
import { VoiceVisualizer } from "@/visualizers";
import {
  type OptionalMediaDeviceInfo,
  PipecatClientMicToggle,
  usePipecatClient,
  usePipecatClientMediaDevices,
} from "@pipecat-ai/client-react";
import { useEffect } from "react";
import { DeviceDropDown } from "./DeviceDropDown";

interface Props {
  variant?: ButtonVariant;
  size?: ButtonSize;
  state?: ButtonState;
  buttonProps?: Partial<React.ComponentProps<typeof Button>>;
  classNames?: {
    button?: string;
    buttongroup?: string;
    dropdownMenuTrigger?: string;
    dropdownMenuContent?: string;
    dropdownMenuCheckboxItem?: string;
  };
  dropdownButtonProps?: Partial<React.ComponentProps<typeof Button>>;
  noDevicePicker?: boolean;
  noVisualizer?: boolean;
  visualizerProps?: Partial<React.ComponentProps<typeof VoiceVisualizer>>;
  noAudio?: boolean;
  noAudioText?: string | null;
}

interface ComponentProps extends Props {
  onClick?: () => void;
  isMicEnabled?: boolean;
  availableMics?: MediaDeviceInfo[];
  selectedMic?: OptionalMediaDeviceInfo;
  updateMic?: (deviceId: string) => void;
}

const btnClasses = "vkui:flex-1 vkui:w-full vkui:z-10 vkui:justify-start";

export const UserAudioComponent: React.FC<ComponentProps> = ({
  variant = "secondary",
  size = "default",
  classNames = {},
  buttonProps = {},
  dropdownButtonProps = {},
  noDevicePicker = false,
  noVisualizer = false,
  visualizerProps = {},
  isMicEnabled = false,
  state,
  availableMics,
  selectedMic,
  updateMic,
  noAudio,
  noAudioText = "Audio disabled",
  onClick,
}) => {
  if (noAudio || buttonProps?.isLoading) {
    return (
      <Button
        variant={variant}
        size={size}
        {...buttonProps}
        disabled
        className={cn(
          btnClasses,
          buttonProps?.isLoading && "vkui:justify-center",
          classNames.button,
        )}
      >
        {!buttonProps?.isLoading && (
          <>
            <MicOffIcon />
            <span className="vkui:flex-1">{noAudioText}</span>
          </>
        )}
      </Button>
    );
  }

  const buttonState = state || (isMicEnabled ? "default" : "inactive");
  const accentColor =
    buttonAccentColorMap[variant || "default"]?.[buttonState] || "black";

  const button = (
    <>
      <Button
        onClick={onClick}
        className={cn(btnClasses, classNames.button)}
        variant={variant}
        state={buttonState}
        size={size}
        {...buttonProps}
      >
        {isMicEnabled ? <MicIcon /> : <MicOffIcon />}
        {!noVisualizer && (
          <VoiceVisualizer
            participantType="local"
            backgroundColor="transparent"
            barCount={10}
            barGap={2}
            barMaxHeight={size === "lg" ? 24 : size === "xl" ? 36 : 20}
            barOrigin="center"
            barWidth={3}
            barColor={accentColor}
            className="vkui:mx-auto"
            {...visualizerProps}
          />
        )}
      </Button>
      {!noDevicePicker && (
        <DeviceDropDown
          menuLabel="Microphone device"
          availableDevices={availableMics}
          selectedDevice={selectedMic}
          updateDevice={updateMic}
          classNames={{
            dropdownMenuContent: classNames.dropdownMenuContent,
            dropdownMenuCheckboxItem: classNames.dropdownMenuCheckboxItem,
          }}
        >
          <Button
            className={cn(
              "vkui:p-2! vkui:flex-none vkui:z-0",
              classNames.dropdownMenuTrigger,
            )}
            variant={variant}
            size={size}
            isIcon
            {...dropdownButtonProps}
          >
            <ChevronDownIcon size={16} />
          </Button>
        </DeviceDropDown>
      )}
    </>
  );

  if (noDevicePicker) {
    return button;
  }

  return (
    <ButtonGroup
      className={cn(
        "vkui:w-full",
        variant !== "outline" && "vkui:gap-[2px]",
        classNames.buttongroup,
      )}
    >
      {button}
    </ButtonGroup>
  );
};

export const UserAudioControl: React.FC<Props> = (props) => {
  const client = usePipecatClient();
  const { availableMics, selectedMic, updateMic } =
    usePipecatClientMediaDevices();

  const hasAudio = client?.isMicEnabled;
  const loading = hasAudio === null;

  useEffect(() => {
    if (!client) return;

    if (["idle", "disconnected"].includes(client.state)) {
      client.initDevices();
    }
  }, [client]);

  return (
    <PipecatClientMicToggle>
      {({ isMicEnabled, onClick }) => (
        <UserAudioComponent
          noAudio={!hasAudio}
          onClick={onClick}
          isMicEnabled={isMicEnabled}
          availableMics={availableMics}
          selectedMic={selectedMic}
          updateMic={updateMic}
          state={isMicEnabled ? "default" : "inactive"}
          buttonProps={{
            isLoading: loading,
          }}
          {...props}
        />
      )}
    </PipecatClientMicToggle>
  );
};

export default UserAudioControl;



================================================
FILE: src/components/elements/UserVideoControl.tsx
================================================
import { Button } from "@/components/ui/button";
import { ButtonGroup } from "@/components/ui/buttongroup";
import { ChevronDownIcon, VideoIcon, VideoOffIcon } from "@/icons";
import { cn } from "@/lib/utils";
import {
  type OptionalMediaDeviceInfo,
  PipecatClientCamToggle,
  PipecatClientVideo,
  usePipecatClientMediaDevices,
} from "@pipecat-ai/client-react";
import { DeviceDropDown } from "./DeviceDropDown";

interface Props {
  buttonProps?: Partial<React.ComponentProps<typeof Button>>;
  classNames?: {
    container?: string;
    video?: string;
    buttongroup?: string;
    button?: string;
    dropdownMenuTrigger?: string;
    dropdownMenuContent?: string;
    dropdownMenuCheckboxItem?: string;
    videoOffContainer?: string;
    videoOffText?: string;
  };
  dropdownButtonProps?: Partial<React.ComponentProps<typeof Button>>;
  noDevicePicker?: boolean;
  noVideo?: boolean;
  videoProps?: Partial<React.ComponentProps<typeof PipecatClientVideo>>;
}

interface ComponentProps extends Props {
  onClick?: () => void;
  isCamEnabled?: boolean;
  availableCams?: MediaDeviceInfo[];
  selectedCam?: OptionalMediaDeviceInfo;
  updateCam?: (deviceId: string) => void;
}

export const UserVideoComponent: React.FC<ComponentProps> = ({
  buttonProps = {},
  classNames = {},
  dropdownButtonProps = {},
  noDevicePicker = false,
  noVideo = false,
  videoProps = {},
  onClick,
  isCamEnabled,
  availableCams = [],
  selectedCam,
  updateCam,
}) => {
  return (
    <div
      className={cn(
        "vkui:bg-muted vkui:rounded-xl vkui:relative",
        {
          "vkui:aspect-video": isCamEnabled && !noVideo,
          "vkui:h-12": !isCamEnabled || noVideo,
        },
        classNames.container,
      )}
    >
      {!noVideo && (
        <PipecatClientVideo
          className={cn(
            "vkui:rounded-xl",
            {
              "vkui:hidden": !isCamEnabled,
            },
            classNames.video,
          )}
          participant="local"
          {...videoProps}
        />
      )}
      {(!isCamEnabled || noVideo) && (
        <div
          className={cn(
            "vkui:absolute vkui:h-full vkui:left-28 vkui:flex vkui:items-center vkui:justify-start vkui:rounded-xl",
            {
              "vkui:left-16": noDevicePicker,
            },
            classNames.videoOffContainer,
          )}
        >
          <div
            className={cn(
              "vkui:text-muted-foreground vkui:font-mono vkui:text-sm",
              classNames.videoOffText,
            )}
          >
            {isCamEnabled ? "Camera is on" : "Camera is off"}
          </div>
        </div>
      )}
      <div className="vkui:absolute vkui:bottom-2 vkui:left-2">
        <ButtonGroup className={cn(classNames.buttongroup)}>
          <Button
            className={cn(classNames.button)}
            variant="outline"
            onClick={onClick}
            {...buttonProps}
          >
            {isCamEnabled ? <VideoIcon /> : <VideoOffIcon />}
          </Button>
          {!noDevicePicker && (
            <DeviceDropDown
              availableDevices={availableCams}
              selectedDevice={selectedCam}
              updateDevice={updateCam}
              classNames={{
                dropdownMenuCheckboxItem: classNames.dropdownMenuCheckboxItem,
                dropdownMenuContent: classNames.dropdownMenuContent,
                dropdownMenuTrigger: classNames.dropdownMenuTrigger,
              }}
              menuLabel="Camera device"
            >
              <Button
                className={cn(classNames.dropdownMenuTrigger)}
                variant="outline"
                {...dropdownButtonProps}
              >
                <ChevronDownIcon />
              </Button>
            </DeviceDropDown>
          )}
        </ButtonGroup>
      </div>
    </div>
  );
};

export const UserVideoControl: React.FC<Props> = (props) => {
  const { availableCams, selectedCam, updateCam } =
    usePipecatClientMediaDevices();

  return (
    <PipecatClientCamToggle>
      {({ isCamEnabled, onClick }) => (
        <UserVideoComponent
          {...props}
          isCamEnabled={isCamEnabled}
          onClick={onClick}
          availableCams={availableCams}
          selectedCam={selectedCam}
          updateCam={updateCam}
        />
      )}
    </PipecatClientCamToggle>
  );
};
export default UserVideoControl;



================================================
FILE: src/components/helpers/AudioClientHelper.tsx
================================================
"use client";

import {
  type ConnectionEndpoint,
  PipecatClient,
  type PipecatClientOptions,
  type TransportConnectionParams,
} from "@pipecat-ai/client-js";
import {
  PipecatClientAudio,
  PipecatClientProvider,
} from "@pipecat-ai/client-react";
import { DailyTransport } from "@pipecat-ai/daily-transport";
import { SmallWebRTCTransport } from "@pipecat-ai/small-webrtc-transport";
import { useEffect, useState } from "react";
import { ThemeProvider } from "../ThemeProvider";

/**
 * Props for the AudioClientHelper component.
 */
export interface AppProps {
  /** Connection parameters for the Pipecat client */
  connectParams: TransportConnectionParams | ConnectionEndpoint;
  /** Type of transport to use for the connection */
  transportType: "smallwebrtc" | "daily";
  /** Optional configuration options for the Pipecat client */
  clientOptions?: PipecatClientOptions;
  /**
   * Render prop function that receives helper props and returns React nodes.
   *
   * @param props - HelperChildProps including connection handlers, loading, and error state
   * @returns React.ReactNode
   */
  children: (props: HelperChildProps) => React.ReactNode;
}

/**
 * Props that are passed to child components by the AudioClientHelper.
 */
export interface HelperChildProps {
  /** Function to initiate a connection to the session */
  handleConnect?: () => Promise<void>;
  /** Function to disconnect from the current session */
  handleDisconnect?: () => Promise<void>;
  /** Loading state */
  loading?: boolean;
  /** Error message if connection fails */
  error?: string | null;
}

/**
 * AudioClientHelper component that provides a configured Pipecat client with audio capabilities.
 *
 * This component:
 * - Initializes a Pipecat client with the specified transport type
 * - Provides connection and disconnection handlers
 * - Wraps children in the necessary providers (ThemeProvider, PipecatClientProvider)
 * - Handles error states and loading states
 * - Automatically disconnects the client when unmounting
 *
 * @param props - Configuration for the audio client including connection params and transport type
 * @returns A provider component that wraps children with client context and handlers
 *
 * @example
 * ```tsx
 * <AudioClientHelper
 *   connectParams={...}
 *   transportType="daily"
 * >
 *   {({ handleConnect, handleDisconnect, loading, error }) => (
 *     <YourComponent
 *       handleConnect={handleConnect}
 *       handleDisconnect={handleDisconnect}
 *       loading={loading}
 *       error={error}
 *     />
 *   )}
 * </AudioClientHelper>
 * ```
 */
export const AudioClientHelper = ({
  connectParams,
  transportType,
  clientOptions,
  children,
}: AppProps) => {
  const [client, setClient] = useState<PipecatClient | null>(null);
  const [error, setError] = useState<string | null>(null);

  /**
   * Initializes the Pipecat client with the specified transport type.
   * Creates a new client instance when transport type or connection params change.
   */
  useEffect(() => {
    let transport: DailyTransport | SmallWebRTCTransport;
    switch (transportType) {
      case "smallwebrtc":
        transport = new SmallWebRTCTransport();
        break;
      case "daily":
      default:
        transport = new DailyTransport();
        break;
    }

    const pcClient = new PipecatClient({
      enableCam: false,
      enableMic: true,
      transport: transport,
      ...clientOptions,
    });
    setClient(pcClient);

    return () => {
      /**
       * Disconnect client when component unmounts or options change.
       */
      pcClient.disconnect();
    };
  }, [connectParams, transportType, clientOptions]);

  /**
   * Initiates a connection to the session using the configured client.
   * Only allows connection from specific states (initialized, disconnected, error).
   * Clears any previous errors and handles connection failures.
   */
  const handleConnect = async () => {
    if (
      !client ||
      !["initialized", "disconnected", "error"].includes(client.state)
    ) {
      return;
    }
    setError(null);

    try {
      await client.connect(connectParams);
    } catch (err) {
      console.error("Connection error:", err);
      setError(
        `Failed to start session: ${err instanceof Error ? err.message : String(err)}`,
      );
    }
  };

  /**
   * Disconnects from the current session.
   * Safely handles the case where no client is available.
   */
  const handleDisconnect = async () => {
    if (!client) return;
    await client.disconnect();
  };

  /**
   * Show loading state while client is being initialized.
   */
  if (!client) {
    return children({ loading: true, error: null });
  }

  return (
    <ThemeProvider>
      <PipecatClientProvider client={client!}>
        {children({
          handleConnect,
          handleDisconnect,
          loading: false,
          error,
        })}
        <PipecatClientAudio />
      </PipecatClientProvider>
    </ThemeProvider>
  );
};



================================================
FILE: src/components/helpers/index.ts
================================================
export * from "./AudioClientHelper";



================================================
FILE: src/components/metrics/index.ts
================================================
export { Metrics } from "./Metrics";



================================================
FILE: src/components/metrics/Metrics.tsx
================================================
import { RTVIEvent } from "@pipecat-ai/client-js";
import {
  usePipecatClientTransportState,
  useRTVIClientEvent,
} from "@pipecat-ai/client-react";
import {
  CategoryScale,
  Chart as ChartJS,
  type ChartOptions,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from "chart.js";
import { useState } from "react";
import { Line } from "react-chartjs-2";
import { cn } from "../../lib/utils";

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
);

interface ProcessingMetric {
  processor: string;
  value: number;
}

interface MetricData {
  timestamp: string;
  value: number;
}

interface MetricsState {
  [processorName: string]: MetricData[];
}

interface TokenMetrics {
  completion_tokens: number;
  prompt_tokens: number;
  total_tokens: number;
}

interface Props {
  chartOptions?: ChartOptions<"line">;
  classNames?: {
    container?: string;
    heading?: string;
    metricsContainer?: string;
    metricsCard?: string;
    metricsTitle?: string;
    metricsChart?: string;
    tokenContainer?: string;
    tokenCard?: string;
    tokenType?: string;
    tokenValue?: string;
  };
  ignoreProcessorNames?: string[];
  noPromptTokens?: boolean;
  noCompletionTokens?: boolean;
  noTotalTokens?: boolean;
}

export const Metrics: React.FC<Props> = ({
  chartOptions = {},
  classNames = {},
  ignoreProcessorNames = [],
  noPromptTokens = false,
  noCompletionTokens = false,
  noTotalTokens = false,
}) => {
  const [metrics, setMetrics] = useState<MetricsState>({});
  const [tokenMetrics, setTokenMetrics] = useState<Partial<TokenMetrics>>({});

  const transportState = usePipecatClientTransportState();

  useRTVIClientEvent(RTVIEvent.Connected, () => {
    setMetrics({});
    setTokenMetrics({
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0,
    });
  });

  useRTVIClientEvent(RTVIEvent.Metrics, (data) => {
    // Handle processing metrics
    if (data?.processing && Array.isArray(data.processing)) {
      const timestamp = new Date().toISOString();

      setMetrics((prevMetrics) => {
        const newMetrics = { ...prevMetrics };

        (data.processing ?? []).forEach((item: ProcessingMetric) => {
          const { processor, value } = item;

          if (ignoreProcessorNames.includes(processor)) {
            return; // Skip ignored processors
          }

          if (!newMetrics[processor]) {
            newMetrics[processor] = [];
          }

          // Limit array to last 100 entries to prevent excessive memory use
          const updatedMetrics = [
            ...newMetrics[processor],
            { timestamp, value },
          ].slice(-100);

          newMetrics[processor] = updatedMetrics;
        });

        return newMetrics;
      });
    }

    // Handle token metrics
    // @ts-expect-error - tokens type not defined
    const tokens = data?.tokens;
    if (tokens && Array.isArray(tokens) && tokens.length > 0) {
      const tokenData = tokens[0];

      setTokenMetrics((prev) => ({
        completion_tokens:
          prev.completion_tokens +
          (noCompletionTokens ? 0 : tokenData.completion_tokens || 0),
        prompt_tokens:
          prev.prompt_tokens +
          (noPromptTokens ? 0 : tokenData.prompt_tokens || 0),
        total_tokens:
          prev.total_tokens + (noTotalTokens ? 0 : tokenData.total_tokens || 0),
      }));
    }
  });

  const generateChartData = (processorName: string, data: MetricData[]) => {
    return {
      labels: data.map((d) => {
        const date = new Date(d.timestamp);
        return `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`;
      }),
      datasets: [
        {
          label: `TTFB (${processorName})`,
          data: data.map((d) => d.value * 1000), // Convert to ms for better readability
          borderColor: getColorForProcessor(processorName),
          backgroundColor: getColorForProcessor(processorName, 0.2),
          tension: 0.4,
        },
      ],
    };
  };

  // Simple function to generate consistent colors based on processor name
  const getColorForProcessor = (processor: string, alpha = 1) => {
    const hash = processor.split("").reduce((acc, char) => {
      return char.charCodeAt(0) + ((acc << 5) - acc);
    }, 0);
    const h = Math.abs(hash) % 360;
    return `hsla(${h}, 70%, 50%, ${alpha})`;
  };

  const lineChartOptions: ChartOptions<"line"> = {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
      y: {
        title: {
          display: true,
          text: "Time (ms)",
        },
        beginAtZero: true,
      },
      x: {
        title: {
          display: true,
          text: "Time",
        },
        ticks: {
          maxRotation: 0,
          autoSkip: true,
          maxTicksLimit: 10,
        },
      },
    },
    plugins: {
      tooltip: {
        callbacks: {
          label: function (context) {
            return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} ms`;
          },
        },
      },
    },
    ...chartOptions,
  };

  const isConnecting =
    transportState === "authenticating" || transportState === "connecting";
  const isConnected =
    transportState === "connected" || transportState === "ready";

  const hasTokenMetrics = Object.keys(tokenMetrics).length > 0;
  const hasMetrics = Object.keys(metrics).length > 0;

  const tokenCardClassName = cn(
    "vkui:bg-card vkui:rounded-md vkui:p-3 vkui:shadow-sm",
    classNames.tokenCard,
  );
  const tokenTypeClassName = cn(
    "vkui:text-sm vkui:text-muted-foreground",
    classNames.tokenType,
  );
  const tokenValueClassName = cn(
    "vkui:text-2xl vkui:font-medium",
    classNames.tokenValue,
  );

  if (hasMetrics || hasTokenMetrics) {
    return (
      <div
        className={cn(
          "vkui:@container/metrics vkui:grid vkui:gap-6 vkui:items-start vkui:p-4 vkui:max-h-full vkui:overflow-auto",
          classNames.container,
        )}
      >
        {hasTokenMetrics && (
          <>
            <h2
              className={cn(
                "vkui:text-xl vkui:font-semibold",
                classNames.heading,
              )}
            >
              Token Usage
            </h2>
            <div
              className={cn(
                "vkui:grid vkui:grid-cols-1 vkui:@xl/metrics:grid-cols-2 vkui:@3xl/metrics:grid-cols-3 vkui:gap-4",
                classNames.tokenContainer,
              )}
            >
              {!noPromptTokens && (
                <div className={tokenCardClassName}>
                  <div className={tokenTypeClassName}>Prompt Tokens</div>
                  <div className={tokenValueClassName}>
                    {tokenMetrics.prompt_tokens}
                  </div>
                </div>
              )}
              {!noCompletionTokens && (
                <div className={tokenCardClassName}>
                  <div className={tokenTypeClassName}>Completion Tokens</div>
                  <div className={tokenValueClassName}>
                    {tokenMetrics.completion_tokens}
                  </div>
                </div>
              )}
              {!noTotalTokens && (
                <div className={tokenCardClassName}>
                  <div className={tokenTypeClassName}>Total Tokens</div>
                  <div className={tokenValueClassName}>
                    {tokenMetrics.total_tokens}
                  </div>
                </div>
              )}
            </div>
          </>
        )}
        {hasMetrics && (
          <>
            <h2
              className={cn(
                "vkui:text-xl vkui:font-semibold",
                classNames.heading,
              )}
            >
              TTFB Metrics
            </h2>
            <div
              className={cn(
                "vkui:grid vkui:grid-cols-1 vkui:@xl/metrics:grid-cols-2 vkui:@3xl/metrics:grid-cols-3 vkui:gap-4",
                classNames.metricsContainer,
              )}
            >
              {Object.entries(metrics).map(([processorName, data]) => (
                <div
                  key={processorName}
                  className={cn(
                    "vkui:bg-card vkui:border vkui:rounded-lg vkui:shadow-sm vkui:p-3 vkui:h-60",
                    classNames.metricsCard,
                  )}
                >
                  <h3 className={cn("vkui:mb-2", classNames.metricsTitle)}>
                    {processorName}
                  </h3>
                  <div className={cn("vkui:h-44", classNames.metricsChart)}>
                    <Line
                      data={generateChartData(processorName, data)}
                      options={lineChartOptions}
                    />
                  </div>
                </div>
              ))}
            </div>
          </>
        )}
      </div>
    );
  }

  if (isConnecting) {
    return (
      <div
        className={cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-sm",
          classNames.container,
        )}
      >
        Connecting to agent...
      </div>
    );
  }

  if (!isConnected) {
    return (
      <div
        className={cn(
          "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-center",
          classNames.container,
        )}
      >
        <div className="vkui:p-4">
          <div className="vkui:mb-2">Not connected to agent</div>
          <p className="vkui:text-sm vkui:max-w-md">
            Connect to an agent to view metrics in real-time.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div
      className={cn(
        "vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:text-muted-foreground vkui:text-sm",
        classNames.container,
      )}
    >
      Waiting for metrics data...
    </div>
  );
};

export default Metrics;



================================================
FILE: src/components/panels/BotAudioPanel.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import { BotAudioPanel } from "./BotAudioPanel";

export default {
  title: "Panels",
} satisfies StoryDefault;

export const BotAudioPanelPrimary: Story<{
  isMuted: boolean;
}> = ({ isMuted }) => <BotAudioPanel isMuted={isMuted} />;

BotAudioPanelPrimary.args = {
  isMuted: false,
};
BotAudioPanelPrimary.argTypes = {
  isMuted: {
    control: { type: "boolean" },
    defaultValue: false,
  },
};
BotAudioPanelPrimary.storyName = "Bot Audio Panel";



================================================
FILE: src/components/panels/BotAudioPanel.tsx
================================================
import {
  Panel,
  PanelContent,
  PanelHeader,
  PanelTitle,
} from "@/components/ui/panel";
import { MicOffIcon } from "@/icons";
import { cn } from "@/lib/utils";
import {
  usePipecatClientMediaTrack,
  VoiceVisualizer,
} from "@pipecat-ai/client-react";
import { useEffect, useRef, useState } from "react";

interface BotAudioPanelProps {
  audioTracks?: MediaStreamTrack[];
  className?: string;
  collapsed?: boolean;
  visualization?: "bar" | "circle";
  isMuted?: boolean;
  onMuteToggle?: () => void;
}

const barCount = 10;

export const BotAudioPanel: React.FC<BotAudioPanelProps> = ({
  className,
  collapsed = false,
}) => {
  const track = usePipecatClientMediaTrack("audio", "bot");

  const [maxHeight, setMaxHeight] = useState(48);
  const [width, setWidth] = useState(4);

  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;
    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;

        const maxWidth = 240;
        const maxBarWidth = maxWidth / (2 * barCount - 1);
        const maxMaxHeight = 240 / (16 / 9);

        const barWidth = Math.max(
          Math.min(width / (barCount * 2), maxBarWidth),
          2,
        );
        const maxHeight = Math.max(Math.min(height, maxMaxHeight), 20);

        setMaxHeight(maxHeight);
        setWidth(barWidth);
      }
    });
    observer.observe(containerRef.current);
    return () => {
      observer.disconnect();
    };
  }, []);

  return (
    <Panel
      className={cn(
        "vkui:flex-1 vkui:mt-auto",
        {
          "vkui:flex-0 vkui:border-none": collapsed,
        },
        className,
      )}
    >
      {!collapsed && (
        <PanelHeader>
          <PanelTitle>Bot Audio</PanelTitle>
        </PanelHeader>
      )}
      <PanelContent
        className={cn("vkui:overflow-hidden vkui:flex-1", {
          "vkui:aspect-video": collapsed,
        })}
      >
        <div
          ref={containerRef}
          className="vkui:relative vkui:flex vkui:h-full vkui:overflow-hidden"
        >
          {track ? (
            <div className="vkui:m-auto">
              <VoiceVisualizer
                participantType="bot"
                backgroundColor="transparent"
                barColor="#ad46ff"
                barCount={barCount}
                barGap={width}
                barLineCap="square"
                barMaxHeight={maxHeight}
                barOrigin="bottom"
                barWidth={width}
              />
            </div>
          ) : (
            <div className="vkui:text-subtle vkui:flex vkui:w-full vkui:gap-2 vkui:items-center vkui:justify-center">
              <MicOffIcon size={16} />
              {!collapsed && (
                <span className="vkui:font-semibold vkui:text-sm">
                  No audio
                </span>
              )}
            </div>
          )}
        </div>
      </PanelContent>
    </Panel>
  );
};

export default BotAudioPanel;



================================================
FILE: src/components/panels/BotVideoPanel.tsx
================================================
import {
  Panel,
  PanelContent,
  PanelHeader,
  PanelTitle,
} from "@/components/ui/panel";
import { VideoOffIcon } from "@/icons";
import { cn } from "@/lib/utils";
import {
  PipecatClientVideo,
  usePipecatClientMediaTrack,
} from "@pipecat-ai/client-react";

interface BotVideoPanelProps {
  className?: string;
  collapsed?: boolean;
}

export const BotVideoPanel: React.FC<BotVideoPanelProps> = ({
  className,
  collapsed = false,
}) => {
  const track = usePipecatClientMediaTrack("video", "bot");

  return (
    <Panel
      className={cn(
        "vkui:flex-1 vkui:mb-auto",
        {
          "vkui:flex-0 vkui:border-none": collapsed,
        },
        className,
      )}
    >
      {!collapsed && (
        <PanelHeader>
          <PanelTitle>Bot Video</PanelTitle>
        </PanelHeader>
      )}
      <PanelContent
        className={cn("vkui:overflow-hidden vkui:flex-1", {
          "vkui:aspect-video": collapsed,
        })}
      >
        {track ? (
          <div
            className={cn(
              "vkui:relative vkui:flex vkui:h-full vkui:bg-muted vkui:rounded-sm",
              {
                "vkui:aspect-video": collapsed,
              },
            )}
          >
            <PipecatClientVideo
              participant="bot"
              className="vkui:aspect-video vkui:max-h-full"
              fit="contain"
            />
          </div>
        ) : (
          <div className="vkui:text-subtle vkui:flex vkui:w-full vkui:h-full vkui:gap-2 vkui:items-center vkui:justify-center">
            <VideoOffIcon size={16} />
            {!collapsed && (
              <span className="vkui:font-semibold vkui:text-sm">No video</span>
            )}
          </div>
        )}
      </PanelContent>
    </Panel>
  );
};

export default BotVideoPanel;



================================================
FILE: src/components/panels/ConversationPanel.tsx
================================================
import Conversation from "@/components/elements/Conversation";
import { Metrics } from "@/components/metrics";
import { Panel, PanelContent, PanelHeader } from "@/components/ui/panel";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { LineChartIcon, MessagesSquareIcon } from "@/icons";

interface Props {
  noConversation?: boolean;
  noMetrics?: boolean;
}

export const ConversationPanel: React.FC<Props> = ({
  noConversation = false,
  noMetrics = false,
}) => {
  const defaultValue = noConversation ? "metrics" : "conversation";
  return (
    <Tabs className="vkui:h-full" defaultValue={defaultValue}>
      <Panel className="vkui:h-full vkui:max-sm:border-none">
        <PanelHeader variant="noPadding" className="vkui:py-1.5">
          <TabsList>
            {!noConversation && (
              <TabsTrigger value="conversation">
                <MessagesSquareIcon size={20} />
                Conversation
              </TabsTrigger>
            )}
            {!noMetrics && (
              <TabsTrigger value="metrics">
                <LineChartIcon size={20} />
                Metrics
              </TabsTrigger>
            )}
          </TabsList>
        </PanelHeader>
        <PanelContent className="vkui:p-0! vkui:overflow-hidden vkui:h-full">
          {!noConversation && (
            <TabsContent
              value="conversation"
              className="vkui:overflow-hidden vkui:h-full"
            >
              <Conversation />
            </TabsContent>
          )}
          {!noMetrics && (
            <TabsContent value="metrics" className="vkui:h-full">
              <Metrics />
            </TabsContent>
          )}
        </PanelContent>
      </Panel>
    </Tabs>
  );
};

export default ConversationPanel;



================================================
FILE: src/components/panels/EventsPanel.tsx
================================================
import { Input } from "@/components/ui/input";
import {
  Panel,
  PanelContent,
  PanelHeader,
  PanelTitle,
} from "@/components/ui/panel";
import { FunnelIcon } from "@/icons";
import { cn } from "@/lib/utils";
import { RTVIEvent } from "@pipecat-ai/client-js";
import {
  usePipecatClient,
  usePipecatClientTransportState,
  useRTVIClientEvent,
} from "@pipecat-ai/client-react";
import { Fragment, useCallback, useEffect, useRef, useState } from "react";

interface EventData {
  event: RTVIEvent | string;
  message: string;
  time: string;
}

interface Props {
  collapsed?: boolean;
}

export const EventsPanel: React.FC<Props> = ({ collapsed = false }) => {
  const client = usePipecatClient();
  const [events, setEvents] = useState<EventData[]>([]);

  const scrollRef = useRef<HTMLDivElement>(null);
  const isScrolledToBottom = useRef(true);

  const addEvent = useCallback((data: EventData) => {
    if (scrollRef.current) {
      isScrolledToBottom.current =
        Math.ceil(
          scrollRef.current.scrollHeight - scrollRef.current.scrollTop,
        ) <= Math.ceil(scrollRef.current.clientHeight);
    }
    setEvents((prev) => {
      return [...prev, data];
    });
  }, []);

  const transportState = usePipecatClientTransportState();
  const lastTransportState = useRef("");
  useEffect(() => {
    if (transportState === lastTransportState.current) return;
    addEvent({
      event: "transportState",
      message: `Transport state changed: ${transportState}`,
      time: new Date().toLocaleTimeString(),
    });
    lastTransportState.current = transportState;
  }, [addEvent, transportState]);

  useEffect(() => {
    if (!client) return;
    addEvent({
      event: "initialized",
      message: `RTVI Client initialized (version ${client.version})`,
      time: new Date().toLocaleTimeString(),
    });
  }, [addEvent, client]);

  useRTVIClientEvent(RTVIEvent.BotConnected, (participant) => {
    addEvent({
      event: RTVIEvent.BotConnected,
      message: `Bot connected: ${participant.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.BotDisconnected, (participant) => {
    addEvent({
      event: RTVIEvent.BotDisconnected,
      message: `Bot disconnected: ${participant.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.BotReady, (botData) => {
    addEvent({
      event: RTVIEvent.BotReady,
      message: `Bot ready (v${botData.version}): ${JSON.stringify(botData.about ?? {})}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.BotStartedSpeaking, () => {
    addEvent({
      event: RTVIEvent.BotStartedSpeaking,
      message: "Bot started speaking",
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.BotStoppedSpeaking, () => {
    addEvent({
      event: RTVIEvent.BotStoppedSpeaking,
      message: "Bot stopped speaking",
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.Connected, () => {
    addEvent({
      event: RTVIEvent.Connected,
      message: "Client connected",
      time: new Date().toLocaleTimeString(),
    });
  });
  useRTVIClientEvent(RTVIEvent.Disconnected, () => {
    addEvent({
      event: RTVIEvent.Disconnected,
      message: "Client disconnected",
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.Error, (message) => {
    addEvent({
      event: RTVIEvent.Error,
      message: `Error: ${JSON.stringify(message)}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.ParticipantConnected, (participant) => {
    addEvent({
      event: RTVIEvent.ParticipantConnected,
      message: `Participant connected: ${participant.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });
  useRTVIClientEvent(RTVIEvent.ParticipantLeft, (participant) => {
    addEvent({
      event: RTVIEvent.ParticipantLeft,
      message: `Participant left: ${participant.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.ServerMessage, (data) => {
    addEvent({
      event: RTVIEvent.ServerMessage,
      message: `Server message: ${JSON.stringify(data)}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.TrackStarted, (track, participant) => {
    addEvent({
      event: RTVIEvent.TrackStarted,
      message: `Track started: ${track.kind} for participant ${participant?.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.TrackStopped, (track, participant) => {
    addEvent({
      event: RTVIEvent.TrackStopped,
      message: `Track stopped: ${track.kind} for participant ${participant?.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.ScreenTrackStarted, (track, participant) => {
    addEvent({
      event: RTVIEvent.ScreenTrackStarted,
      message: `Screen track started: ${track.kind} for participant ${participant?.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });
  useRTVIClientEvent(RTVIEvent.ScreenTrackStopped, (track, participant) => {
    addEvent({
      event: RTVIEvent.ScreenTrackStopped,
      message: `Screen track stopped: ${track.kind} for participant ${participant?.id}`,
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.UserStartedSpeaking, () => {
    addEvent({
      event: RTVIEvent.UserStartedSpeaking,
      message: "User started speaking",
      time: new Date().toLocaleTimeString(),
    });
  });

  useRTVIClientEvent(RTVIEvent.UserStoppedSpeaking, () => {
    addEvent({
      event: RTVIEvent.UserStoppedSpeaking,
      message: "User stopped speaking",
      time: new Date().toLocaleTimeString(),
    });
  });

  useEffect(() => {
    if (!scrollRef.current) return;
    if (!isScrolledToBottom.current) return;
    scrollRef.current.scrollTo({
      top: scrollRef.current.scrollHeight,
      behavior: "instant",
    });
  }, [events]);

  const [filter, setFilter] = useState("");
  const filteredEvents = events.filter(
    (eventData) =>
      eventData.event.toString().toLowerCase().includes(filter) ||
      eventData.message.toLowerCase().includes(filter),
  );

  return (
    <Panel
      className={cn(
        "vkui:bg-accent vkui:dark:bg-accent/50 vkui:h-full vkui:rounded-none! vkui:max-sm:border-none vkui:sm:border-x-0 vkui:sm:mt-2",
        {
          "vkui:bg-accent vkui:opacity-50": collapsed,
        },
      )}
    >
      <PanelHeader
        className={cn(
          "vkui:gap-4 vkui:justify-start vkui:items-center vkui:@md:py-2 vkui:bg-background",
          {
            "vkui:py-2!": collapsed,
          },
        )}
      >
        <PanelTitle>Events</PanelTitle>
        {!collapsed && (
          <div className="vkui:relative">
            <div className="vkui:absolute vkui:inset-y-0 vkui:left-0 vkui:flex vkui:items-center vkui:pl-2 vkui:pointer-events-none">
              <FunnelIcon size={16} />
            </div>
            <Input
              type="text"
              placeholder="Filter"
              className="vkui:bg-secondary vkui:max-w-48 vkui:ps-8"
              onChange={(e) => {
                setFilter(e.target.value.toLowerCase());
              }}
            />
          </div>
        )}
      </PanelHeader>
      {!collapsed && (
        <PanelContent ref={scrollRef} className="vkui:overflow-y-auto">
          <div className="vkui:grid vkui:grid-cols-[min-content_min-content_1fr] vkui:gap-x-4 vkui:gap-y-2 vkui:items-center vkui:font-mono vkui:text-xs">
            {filteredEvents.map((eventData, index) => (
              <Fragment key={index}>
                <div className="vkui:text-xs vkui:text-muted-foreground vkui:text-nowrap">
                  {eventData.time}
                </div>
                <div className="vkui:font-semibold">{eventData.event}</div>
                <div>{eventData.message}</div>
              </Fragment>
            ))}
          </div>
        </PanelContent>
      )}
    </Panel>
  );
};

export default EventsPanel;



================================================
FILE: src/components/panels/index.ts
================================================
export { BotAudioPanel } from "./BotAudioPanel";
export { BotVideoPanel } from "./BotVideoPanel";
export { ConversationPanel } from "./ConversationPanel";
export { EventsPanel } from "./EventsPanel";
export { InfoPanel } from "./InfoPanel";



================================================
FILE: src/components/panels/InfoPanel.tsx
================================================
import AudioOutput from "@/components/elements/AudioOutput";
import { ClientStatus } from "@/components/elements/ClientStatus";
import { SessionInfo } from "@/components/elements/SessionInfo";
import UserAudioControl from "@/components/elements/UserAudioControl";
import UserVideoControl from "@/components/elements/UserVideoControl";
import {
  Panel,
  PanelContent,
  PanelHeader,
  PanelTitle,
} from "@/components/ui/panel";

interface Props {
  noAudioOutput?: boolean;
  noSessionInfo?: boolean;
  noStatusInfo?: boolean;
  noUserAudio?: boolean;
  noUserVideo?: boolean;
  participantId?: string;
  sessionId?: string;
}

export const InfoPanel: React.FC<Props> = ({
  noAudioOutput = false,
  noSessionInfo = false,
  noStatusInfo = false,
  noUserAudio = false,
  noUserVideo = false,
  participantId,
  sessionId,
}) => {
  const noDevices = noAudioOutput && noUserAudio && noUserVideo;
  const noInfoPanel = noStatusInfo && noDevices && noSessionInfo;

  if (noInfoPanel) return null;

  return (
    <Panel className="vkui:h-full vkui:overflow-y-auto vkui:overflow-x-hidden">
      {!noStatusInfo && (
        <>
          <PanelHeader variant="inline">
            <PanelTitle>Status</PanelTitle>
          </PanelHeader>
          <PanelContent>
            <ClientStatus />
          </PanelContent>
        </>
      )}
      {!noDevices && (
        <>
          <PanelHeader
            className="vkui:border-t vkui:border-t-border"
            variant="inline"
          >
            <PanelTitle>Devices</PanelTitle>
          </PanelHeader>
          <PanelContent>
            {!noUserAudio && <UserAudioControl />}
            {!noUserVideo && <UserVideoControl />}
            {!noAudioOutput && <AudioOutput />}
          </PanelContent>
        </>
      )}
      {!noSessionInfo && (
        <>
          <PanelHeader
            className="vkui:border-t vkui:border-t-border"
            variant="inline"
          >
            <PanelTitle>Session</PanelTitle>
          </PanelHeader>
          <PanelContent>
            <SessionInfo sessionId={sessionId} participantId={participantId} />
          </PanelContent>
        </>
      )}
    </Panel>
  );
};

export default InfoPanel;



================================================
FILE: src/components/ui/banner.tsx
================================================
"use client";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { useControllableState } from "@radix-ui/react-use-controllable-state";
import { type LucideIcon, XIcon } from "lucide-react";
import {
  type ComponentProps,
  createContext,
  type HTMLAttributes,
  type MouseEventHandler,
  useContext,
} from "react";
type BannerContextProps = {
  show: boolean;
  setShow: (show: boolean) => void;
};
const BannerContext = createContext<BannerContextProps>({
  show: true,
  setShow: () => {},
});
export type BannerProps = HTMLAttributes<HTMLDivElement> & {
  visible?: boolean;
  defaultVisible?: boolean;
  onClose?: () => void;
  inset?: boolean;
  variant?: "default" | "destructive";
};
export const Banner = ({
  children,
  visible,
  defaultVisible = true,
  variant = "default",
  onClose,
  className,
  inset = false,
  ...props
}: BannerProps) => {
  const [show, setShow] = useControllableState({
    defaultProp: defaultVisible,
    prop: visible,
    onChange: onClose,
  });
  if (!show) {
    return null;
  }
  return (
    <BannerContext.Provider value={{ show, setShow }}>
      <div
        className={cn(
          "vkui:flex vkui:w-full vkui:font-semibold vkui:items-center vkui:justify-between vkui:gap-2 vkui:bg-primary vkui:px-2 vkui:py-1 vkui:text-primary-foreground",
          inset && "vkui:rounded-lg",
          variant === "destructive" && "vkui:bg-destructive vkui:text-white",
          className,
        )}
        {...props}
      >
        {children}
      </div>
    </BannerContext.Provider>
  );
};
export type BannerIconProps = HTMLAttributes<HTMLDivElement> & {
  icon: LucideIcon;
};
export const BannerIcon = ({
  icon: Icon,
  className,
  ...props
}: BannerIconProps) => (
  <div
    className={cn(
      "vkui:rounded-full vkui:bg-foreground/10 vkui:dark:bg-foreground/30 vkui:p-1",
      className,
    )}
    {...props}
  >
    <Icon size={16} />
  </div>
);
export type BannerTitleProps = HTMLAttributes<HTMLParagraphElement>;
export const BannerTitle = ({ className, ...props }: BannerTitleProps) => (
  <p className={cn("vkui:flex-1 vkui:text-sm", className)} {...props} />
);
export type BannerActionProps = ComponentProps<typeof Button>;
export const BannerAction = ({
  variant = "ghost",
  size = "sm",
  className,
  ...props
}: BannerActionProps) => (
  <Button
    className={cn(
      "vkui:shrink-0 vkui:bg-transparent vkui:hover:bg-background/10 vkui:hover:text-background",
      className,
    )}
    size={size}
    variant={variant}
    {...props}
  />
);
export type BannerCloseProps = ComponentProps<typeof Button>;
export const BannerClose = ({
  variant = "ghost",
  size = "icon",
  onClick,
  className,
  ...props
}: BannerCloseProps) => {
  const { setShow } = useContext(BannerContext);
  const handleClick: MouseEventHandler<HTMLButtonElement> = (e) => {
    setShow(false);
    onClick?.(e);
  };
  return (
    <Button
      className={cn(
        "vkui:shrink-0 vkui:bg-transparent vkui:hover:bg-background/10 vkui:hover:text-background",
        className,
      )}
      onClick={handleClick}
      size={size}
      variant={variant}
      {...props}
    >
      <XIcon size={18} />
    </Button>
  );
};



================================================
FILE: src/components/ui/blankslates.tsx
================================================
import { cn } from "@/lib/utils";

export const TextDashBlankslate = ({ className }: { className?: string }) => {
  return (
    <span className={cn("vkui:mono-upper vkui:text-subtle/60", className)}>
      ---
    </span>
  );
};



================================================
FILE: src/components/ui/button.stories.tsx
================================================
import { Button } from "@/components/ui/button";
import { LoaderIcon, VolumeOffIcon } from "@/icons";
import type { Story, StoryDefault } from "@ladle/react";
import {
  type ButtonSize,
  buttonSizeOptions,
  type ButtonState,
  buttonStateOptions,
  type ButtonVariant,
  buttonVariantOptions,
} from "./buttonVariants";

export default {
  title: "Primitives",
} satisfies StoryDefault;

export const ButtonPrimary: Story<{
  label: string;
  variant: ButtonVariant;
  size: ButtonSize;
  state: ButtonState;
  isDisabled: boolean;
  isLoading: boolean;
  withIcon: boolean;
}> = ({ label, variant, size, state, isDisabled, isLoading, withIcon }) => (
  <Button
    variant={variant}
    size={size}
    state={state}
    disabled={isDisabled}
    isLoading={isLoading}
  >
    {withIcon && !isLoading && <VolumeOffIcon />}
    {label}
  </Button>
);

ButtonPrimary.args = {
  label: "My Button",
  variant: "default",
  state: "default",
  isDisabled: false,
  isLoading: false,
  withIcon: false,
};

ButtonPrimary.argTypes = {
  variant: {
    options: buttonVariantOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  size: {
    options: buttonSizeOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  state: {
    options: buttonStateOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
};

ButtonPrimary.storyName = "Button";

export const ButtonIcon: Story<{
  variant: ButtonVariant;
  size: ButtonSize;
  state: ButtonState;
  isDisabled: boolean;
  isLoading: boolean;
}> = ({ variant, size, state, isDisabled, isLoading }) => (
  <Button
    isIcon
    variant={variant}
    size={size}
    state={state}
    disabled={isDisabled || isLoading}
  >
    {isLoading ? (
      <LoaderIcon className="size-4 animate-spin" />
    ) : (
      <VolumeOffIcon />
    )}
  </Button>
);

ButtonIcon.args = {
  variant: "default",
  size: "default",
  state: "default",
  isDisabled: false,
  isLoading: false,
};

ButtonIcon.argTypes = {
  variant: {
    options: buttonVariantOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  size: {
    options: buttonSizeOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  state: {
    options: buttonStateOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
};

ButtonIcon.storyName = "Icon Button";



================================================
FILE: src/components/ui/button.tsx
================================================
import buttonVariants from "@/components/ui/buttonVariants";
import { LoaderIcon } from "@/icons";
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

export function Button({
  className,
  variant,
  size,
  state,
  isIcon,
  isLoading = false,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
    isLoading?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  if (isLoading) {
    return (
      <Comp
        data-slot="button"
        className={cn(
          buttonVariants({ variant, size, state, isIcon, className }),
        )}
        {...props}
        disabled
      >
        <LoaderIcon className="vkui:animate-spin" />
        {props.children}
      </Comp>
    );
  }

  return (
    <Comp
      data-slot="button"
      className={cn(
        buttonVariants({ variant, size, state, isIcon, className }),
      )}
      {...props}
    />
  );
}

export default Button;



================================================
FILE: src/components/ui/buttongroup.stories.tsx
================================================
import type { Story, StoryDefault } from "@ladle/react";
import { Button } from "./button";
import { ButtonGroup } from "./buttongroup";
import {
  type ButtonSize,
  buttonSizeOptions,
  type ButtonVariant,
  buttonVariantOptions,
} from "./buttonVariants";

export default {
  title: "Primitives",
} satisfies StoryDefault;

export const ButtonGroupDefault: Story<{
  variant: ButtonVariant;
  size: ButtonSize;
  orientation: "horizontal" | "vertical";
}> = ({ variant, size, orientation }) => (
  <ButtonGroup orientation={orientation}>
    <Button variant={variant} size={size}>
      Button 1
    </Button>
    <Button variant={variant} size={size}>
      Button 2
    </Button>
    <Button variant={variant} size={size}>
      Button 3
    </Button>
  </ButtonGroup>
);

ButtonGroupDefault.args = {
  variant: "default",
  orientation: "horizontal",
};

ButtonGroupDefault.argTypes = {
  variant: {
    options: buttonVariantOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  size: {
    options: buttonSizeOptions,
    control: { type: "select" },
    defaultValue: "default",
  },
  orientation: {
    options: ["horizontal", "vertical"],
    control: { type: "select" },
    defaultValue: "horizontal",
  },
};

ButtonGroupDefault.storyName = "Button Group";



================================================
FILE: src/components/ui/buttongroup.tsx
================================================
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonGroupVariants = cva(
  "vkui:flex vkui:items-center vkui:button-group",
  {
    variants: {
      orientation: {
        horizontal:
          "vkui:flex-row vkui:*:first:rounded-e-none vkui:*:last:rounded-s-none vkui:*:-ml-[1px] vkui:*:first:ml-0",
        vertical:
          "vkui:flex-col vkui:*:first:rounded-b-none vkui:*:last:rounded-t-none vkui:*:-mt-[1px] vkui:*:first:mt-0 vkui:*:self-stretch",
      },
    },
    defaultVariants: {
      orientation: "horizontal",
    },
  },
);

export const ButtonGroup = ({
  className,
  orientation = "horizontal",
  children,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof buttonGroupVariants>) => {
  return (
    <div
      className={cn(
        "vkui:flex",
        buttonGroupVariants({ orientation }),
        className,
      )}
      {...props}
    >
      {children}
    </div>
  );
};

export default ButtonGroup;



================================================
FILE: src/components/ui/buttonVariants.ts
================================================
import { cva } from "class-variance-authority";

export const buttonVariants = cva(
  "vkui:border vkui:inline-flex vkui:items-center vkui:justify-center vkui:gap-2 vkui:whitespace-nowrap vkui:rounded-element vkui:text-sm vkui:font-medium vkui:transition-all vkui:disabled:pointer-events-none vkui:disabled:opacity-50 vkui:[&_svg]:pointer-events-none vkui:shrink-0 vkui:[&_svg]:shrink-0 vkui:outline-none vkui:focus-visible:ring-ring/50 vkui:focus-visible:ring-[3px] vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "vkui:bg-primary vkui:text-primary-foreground vkui:hover:bg-primary/90 vkui:border-transparent",
        secondary:
          "vkui:bg-secondary vkui:border-transparent vkui:text-secondary-foreground vkui:hover:bg-secondary/60 vkui:focus-visible:border-secondary",
        outline:
          "vkui:text-foreground vkui:border vkui:bg-background vkui:hover:bg-accent vkui:dark:bg-input/30 vkui:dark:border-input vkui:dark:hover:bg-input/50 vkui:focus-visible:border-ring",
        destructive:
          "vkui:bg-destructive vkui:border-transparent vkui:text-white vkui:hover:bg-destructive/90 vkui:focus-visible:ring-destructive/20 vkui:dark:focus-visible:ring-destructive/40 vkui:dark:bg-destructive/60",
        ghost:
          "vkui:text-foreground vkui:border vkui:border-transparent vkui:hover:bg-accent vkui:hover:text-accent-foreground vkui:dark:hover:bg-accent/50",
        link: "vkui:text-primary vkui:underline-offset-4 vkui:hover:underline vkui:border vkui:border-transparent",
        active:
          "vkui:bg-active vkui:border vkui:border-transparent vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40",
        inactive:
          "vkui:bg-inactive vkui:border vkui:border-transparent vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40",
      },
      size: {
        default:
          "vkui:h-8 vkui:px-4 vkui:py-2 vkui:has-[>svg]:px-3 vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:h-7 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
        sm: "vkui:h-7 vkui:rounded-element vkui:gap-1.5 vkui:px-3 vkui:has-[>svg]:px-2.5 vkui:[&_svg:not([class*='size-'])]:size-4 vkui:@max-xs/panel:h-6 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-3",
        lg: "vkui:h-10 vkui:rounded-element vkui:px-6 vkui:has-[>svg]:px-4 vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:h-9 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
        xl: "vkui:h-12 vkui:rounded-element vkui:px-8 vkui:text-lg vkui:has-[>svg]:px-6 vkui:[&_svg:not([class*='size-'])]:size-6 vkui:gap-3 vkui:@max-xs/panel:h-10 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-5",
        icon: "vkui:h-8 vkui:w-8 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-5",
        "icon-sm":
          "vkui:h-7 vkui:w-7 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        "icon-xs":
          "vkui:h-6 vkui:w-6 vkui:p-0 vkui:has-[>svg]:p-0 vkui:[&_svg:not([class*='size-'])]:size-3",
      },
      state: {
        default: "",
        active: "",
        inactive: "",
      },
      isIcon: {
        true: "",
        false: "",
      },
    },
    compoundVariants: [
      {
        size: "default",
        isIcon: true,
        className:
          "vkui:size-8 vkui:@max-xs/panel:size-7 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
      },
      {
        size: "sm",
        isIcon: true,
        className:
          "vkui:size-7 vkui:@max-xs/panel:size-6 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-4 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-3",
      },
      {
        size: "lg",
        isIcon: true,
        className:
          "vkui:size-10 vkui:@max-xs/panel:size-9 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
      },
      {
        size: "xl",
        isIcon: true,
        className:
          "vkui:size-12 vkui:rounded-element vkui:[&_svg:not([class*='size-'])]:size-5 vkui:@max-xs/panel:[&_svg:not([class*='size-'])]:size-4",
      },
      {
        variant: "default",
        state: "active",
        className:
          "vkui:bg-active vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40",
      },
      {
        variant: "default",
        state: "inactive",
        className:
          "vkui:bg-inactive vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40",
      },
      {
        variant: "secondary",
        state: "active",
        className:
          "vkui:bg-active vkui:text-active-foreground vkui:hover:bg-active/90 vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40 vkui:focus-visible:border-active",
      },
      {
        variant: "secondary",
        state: "inactive",
        className:
          "vkui:bg-inactive vkui:text-inactive-foreground vkui:hover:bg-inactive/90 vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40 vkui:focus-visible:border-inactive",
      },
      {
        variant: "outline",
        state: "active",
        className:
          "vkui:bg-active-accent vkui:text-active vkui:border-active vkui:hover:bg-active-accent/60 vkui:dark:bg-active-accent vkui:dark:hover:bg-active-accent/60 vkui:dark:border-active vkui:focus-visible:border-active vkui:focus-visible:ring-active/20 vkui:dark:focus-visible:ring-active/40",
      },
      {
        variant: "outline",
        state: "inactive",
        className:
          "vkui:bg-inactive-accent vkui:text-inactive vkui:border-inactive vkui:hover:bg-inactive-accent/60 vkui:dark:bg-inactive-accent vkui:dark:hover:bg-inactive-accent/60 vkui:dark:border-inactive vkui:focus-visible:border-inactive vkui:focus-visible:ring-inactive/20 vkui:dark:focus-visible:ring-inactive/40",
      },
    ],
    defaultVariants: {
      variant: "default",
      size: "default",
      state: "default",
      isIcon: false,
    },
  },
);

export type ButtonVariant = NonNullable<
  Parameters<typeof buttonVariants>[0]
>["variant"];
export type ButtonSize = NonNullable<
  Parameters<typeof buttonVariants>[0]
>["size"];
export type ButtonState = NonNullable<
  Parameters<typeof buttonVariants>[0]
>["state"];

export const buttonVariantOptions = [
  "default",
  "outline",
  "secondary",
  "ghost",
  "link",
  "destructive",
  "active",
  "inactive",
] as const;
export const buttonSizeOptions = ["default", "sm", "lg", "xl"] as const;
export const buttonStateOptions = ["default", "active", "inactive"] as const;

export const buttonAccentColorMap: Record<
  (typeof buttonVariantOptions)[number],
  Record<(typeof buttonStateOptions)[number], string>
> = {
  default: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active",
  },
  secondary: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active",
  },
  outline: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive",
    active: "--vkui-color-active",
  },
  destructive: {
    default: "--vkui-color-background",
    inactive: "--vkui-color-background",
    active: "--vkui-color-background",
  },
  ghost: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-border",
    active: "--vkui-color-active",
  },
  link: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive",
    active: "--vkui-color-active",
  },
  active: {
    default: "--vkui-color-active",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-active",
  },
  inactive: {
    default: "--vkui-color-inactive",
    inactive: "--vkui-color-inactive-foreground",
    active: "--vkui-color-inactive",
  },
};
export default buttonVariants;



================================================
FILE: src/components/ui/card.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";

const cardVariants = cva("vkui:text-card-foreground vkui:flex vkui:flex-col", {
  variants: {
    size: {
      default: "vkui:gap-2 vkui:p-2 vkui:rounded-element vkui:shadow-short",
      sm: "vkui:gap-1 vkui:p-1 vkui:rounded-md vkui:shadow-xshort",
      lg: "vkui:gap-3 vkui:p-3 vkui:rounded-2xl vkui:shadow-long",
    },
  },
});

export interface CardProps extends React.ComponentProps<"div"> {
  destructive?: boolean;
  noGradientBorder?: boolean;
  noShadow?: boolean;
  className?: string;
  size?: "sm" | "default" | "lg";
}

function Card({
  className,
  noGradientBorder = false,
  noShadow = false,
  size = "default",
  ...props
}: CardProps) {
  return (
    <div
      data-slot="card"
      className={cn(
        cardVariants({ size }),
        noShadow && "vkui:shadow-none",
        noGradientBorder && "vkui:bg-card vkui:border vkui:border-border",
        !noGradientBorder &&
          "vkui:border vkui:border-transparent vkui:bg-origin-border vkui:borderclip vkui:bg-cardGradientBorder",
        props.destructive && "vkui:text-destructive vkui:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "vkui:flex vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3",
        className,
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("vkui:leading-none vkui:font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("vkui:text-muted-foreground vkui:text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "vkui:col-start-2 vkui:row-span-2 vkui:row-start-1 vkui:self-start vkui:justify-self-end",
        className,
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3", className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn(
        "vkui:flex vkui:gap-2 vkui:md:gap-3 vkui:p-2 vkui:md:p-3",
        className,
      )}
      {...props}
    />
  );
}

export {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
};



================================================
FILE: src/components/ui/container.tsx
================================================
import { cn } from "@/lib/utils";

export function FullScreenContainer({
  className,
  horizontal = false,
  ...props
}: React.ComponentProps<"div"> & { horizontal?: boolean }) {
  return (
    <div
      className={cn(
        "vkui:w-full vkui:h-dvh vkui:bg-background vkui:flex vkui:items-center vkui:justify-center vkui:flex-col",
        horizontal && "vkui:flex-row",
        className,
      )}
      {...props}
    />
  );
}



================================================
FILE: src/components/ui/dropdown-menu.tsx
================================================
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import * as React from "react";

import { CheckIcon, ChevronRightIcon, CircleIcon } from "@/icons";
import { getPipecatUIContainer } from "@/lib/dom";
import { cn } from "@/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal
      container={getPipecatUIContainer()}
      data-slot="dropdown-menu-portal"
      {...props}
    />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPortal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:max-h-(--radix-dropdown-menu-content-available-height) vkui:min-w-[8rem] vkui:origin-(--radix-dropdown-menu-content-transform-origin) vkui:overflow-x-hidden vkui:overflow-y-auto vkui:rounded-element vkui:border vkui:p-1 vkui:shadow-short",
          className,
        )}
        {...props}
      />
    </DropdownMenuPortal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:data-[variant=destructive]:text-destructive vkui:data-[variant=destructive]:focus:bg-destructive/10 vkui:dark:data-[variant=destructive]:focus:bg-destructive/20 vkui:data-[variant=destructive]:focus:text-destructive vkui:data-[variant=destructive]:*:[svg]:!text-destructive vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:data-[inset]:pl-8 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:py-1.5 vkui:pr-2 vkui:pl-8 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        checked && "vkui:font-medium vkui:bg-accent",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="vkui:pointer-events-none vkui:absolute vkui:left-2 vkui:flex size-3.5 vkui:items-center vkui:justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:relative vkui:flex vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-panel vkui:py-1.5 vkui:pr-2 vkui:pl-8 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="vkui:pointer-events-none vkui:absolute vkui:left-2 vkui:flex vkui:size-3.5 vkui:items-center vkui:justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 vkui:fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:font-medium vkui:data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("vkui:bg-border vkui:-mx-1 vkui:my-1 vkui:h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "vkui:text-muted-foreground vkui:ml-auto vkui:text-xs vkui:tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:data-[state=open]:bg-accent vkui:data-[state=open]:text-accent-foreground vkui:flex vkui:cursor-default vkui:items-center vkui:rounded-sm vkui:px-2 vkui:py-1.5 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[inset]:pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="vkui:ml-auto vkui:size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:min-w-[8rem] vkui:origin-(--radix-dropdown-menu-content-transform-origin) vkui:overflow-hidden vkui:rounded-md vkui:border vkui:p-1 vkui:shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};



================================================
FILE: src/components/ui/error.stories.tsx
================================================
import { ErrorCard } from "@/components/ui/error";
import type { Story, StoryDefault } from "@ladle/react";

export default {
  title: "Primitives",
} satisfies StoryDefault;

export const Default: Story<{
  error: string;
}> = ({ error }) => <ErrorCard error={error} />;

Default.args = {
  error: "An error occurred",
};
Default.storyName = "Error Card";



================================================
FILE: src/components/ui/error.tsx
================================================
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { InfoIcon } from "@/icons";
import { cn } from "@/lib/utils";

export const ErrorCard = ({
  title = "An Error Occurred",
  error,
  className,
  noShadow = false,
}: {
  title?: string;
  error: string;
  className?: string;
  noShadow?: boolean;
}) => {
  return (
    <Card
      className={cn(
        "vkui:shadow-long vkui:min-w-md vkui:gap-0",
        noShadow && "vkui:shadow-none",
        className,
      )}
      destructive
    >
      <CardHeader className="vkui:font-semibold vkui:flex vkui:flex-row vkui:items-center">
        <InfoIcon size={24} />
        {title}
      </CardHeader>
      <CardContent>
        <p className="vkui:text-sm vkui:text-balanced">{error}</p>
      </CardContent>
    </Card>
  );
};



================================================
FILE: src/components/ui/index.ts
================================================
export * from "./blankslates";
export * from "./button";
export * from "./buttongroup";
export * from "./card";
export * from "./container";
export * from "./dropdown-menu";
export * from "./error";
export * from "./input";
export * from "./layout";
export * from "./loaders";
export * from "./panel";
export * from "./popover";
export * from "./resizable";
export * from "./select";
export * from "./tabs";
export * from "./tooltip";



================================================
FILE: src/components/ui/input.tsx
================================================
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const inputVariants = cva(
  "vkui:file:text-foreground vkui:placeholder:text-muted-foreground vkui:selection:bg-primary vkui:selection:text-primary-foreground vkui:dark:bg-input/30 vkui:border-input vkui:flex vkui:w-full vkui:min-w-0 vkui:rounded-md vkui:border vkui:bg-transparent vkui:px-3 vkui:text-foreground vkui:transition-[color,box-shadow] vkui:outline-none vkui:file:inline-flex vkui:file:border-0 vkui:file:bg-transparent vkui:file:text-sm vkui:file:font-medium vkui:disabled:pointer-events-none vkui:disabled:cursor-not-allowed vkui:disabled:opacity-50 vkui:md:text-sm vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:focus-visible:ring-[3px] vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive",
  {
    variants: {
      size: {
        sm: "vkui:h-7 vkui:px-2.5 vkui:py-1 vkui:text-sm",
        default: "vkui:h-8 vkui:px-3 vkui:py-1",
        lg: "vkui:h-10 vkui:px-3 vkui:py-2 vkui:rounded-lg",
      },
    },
    defaultVariants: {
      size: "default",
    },
  },
);

export function Input({
  className,
  type,
  size,
  ...props
}: Omit<React.ComponentProps<"input">, "size"> &
  VariantProps<typeof inputVariants>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(inputVariants({ size, className }))}
      {...props}
    />
  );
}

export default Input;



================================================
FILE: src/components/ui/layout.tsx
================================================
import { cn } from "@/lib/utils";

export function LayoutSection({
  className,
  sectionKey,
  ...props
}: React.ComponentProps<"section"> & { sectionKey: string }) {
  return (
    <section data-section={sectionKey} className={cn(className)} {...props} />
  );
}

export default LayoutSection;



================================================
FILE: src/components/ui/loaders.tsx
================================================
import { LoaderIcon } from "@/icons";

export const LoaderSpinner = ({ size = 32 }: { size?: number }) => {
  return (
    <LoaderIcon className="vkui:animate-spin vkui:opacity-50" size={size} />
  );
};



================================================
FILE: src/components/ui/panel.stories.tsx
================================================
import {
  Panel,
  PanelContent,
  PanelHeader,
  PanelTitle,
} from "@/components/ui/panel";
import type { Story, StoryDefault } from "@ladle/react";

export default {
  title: "Primitives",
} satisfies StoryDefault;

export const PanelHeaderDefault: Story<{
  label: string;
  variant: "default" | "inline";
}> = ({ label, variant }) => (
  <Panel>
    <PanelHeader variant={variant}>
      <PanelTitle>{label}</PanelTitle>
    </PanelHeader>
    <PanelContent>My Panel</PanelContent>
  </Panel>
);

PanelHeaderDefault.args = {
  label: "Hello world",
};
PanelHeaderDefault.argTypes = {
  variant: {
    options: ["default", "inline"],
    control: { type: "radio" },
    defaultValue: "default",
  },
};

PanelHeaderDefault.storyName = "Panel";



================================================
FILE: src/components/ui/panel.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

function Panel({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="panel"
      className={cn(
        "vkui:group vkui:@container/panel vkui:bg-card vkui:text-card-foreground vkui:flex vkui:flex-col vkui:rounded-panel vkui:border",
        className,
      )}
      {...props}
    />
  );
}

const PanelHeaderVariants = cva("vkui:@container/panel-header", {
  variants: {
    variant: {
      default:
        "vkui:border-b vkui:flex vkui:items-center vkui:justify-center vkui:text-card-foreground vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4",
      inline:
        "vkui:items-start vkui:text-foreground vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4 vkui:group-has-data-[slot=panel-content]:pb-0",
      noPadding:
        "vkui:border-b vkui:flex vkui:items-center vkui:justify-center vkui:text-card-foreground",
    },
  },
  defaultVariants: {
    variant: "default",
  },
});

function PanelHeader({
  variant,
  className,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof PanelHeaderVariants>) {
  return (
    <div
      data-slot="panel-header"
      className={cn(PanelHeaderVariants({ variant }), className)}
      {...props}
    />
  );
}

function PanelTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="panel-title"
      className={cn("vkui:mono-upper", className)}
      {...props}
    />
  );
}

function PanelContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="panel-content"
      className={cn(
        "vkui:text-foreground vkui:flex vkui:flex-col vkui:gap-2 vkui:p-2 vkui:@xs/panel:p-3 vkui:@xs/panel:gap-3 vkui:@md/panel:p-4 vkui:@md/panel:gap-4",
        className,
      )}
      {...props}
    />
  );
}

function PanelFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="panel-footer"
      className={cn(
        "vkui:flex vkui:items-center vkui:p-2 vkui:@xs/panel:p-3 vkui:@md/panel:p-4",
        className,
      )}
      {...props}
    />
  );
}

function PanelActions({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="panel-actions"
      className={cn(
        "vkui:flex vkui:items-center vkui:gap-1 vkui:@xs/panel:gap-2",
        className,
      )}
      {...props}
    />
  );
}

export {
  Panel,
  PanelActions,
  PanelContent,
  PanelFooter,
  PanelHeader,
  PanelTitle,
};



================================================
FILE: src/components/ui/popover.tsx
================================================
import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { getPipecatUIContainer } from "@/lib/dom";
import { cn } from "@/lib/utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal container={getPipecatUIContainer()}>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:w-72 origin-(--radix-popover-content-transform-origin) vkui:rounded-md vkui:border vkui:p-4 vkui:shadow-md vkui:outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverAnchor, PopoverContent, PopoverTrigger };



================================================
FILE: src/components/ui/resizable.tsx
================================================
import * as React from "react";
import * as ResizablePrimitive from "react-resizable-panels";
import {
  disableGlobalCursorStyles,
  usePanelGroupContext,
} from "react-resizable-panels";

import { EllipsisVerticalIcon } from "@/icons";
import { cn } from "@/lib/utils";

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  disableGlobalCursorStyles();

  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "vkui:flex vkui:h-full vkui:w-full vkui:data-[panel-group-direction=vertical]:flex-col",
        className,
      )}
      {...props}
    />
  );
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />;
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) {
  const { direction } = usePanelGroupContext();
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "vkui:focus-visible:ring-ring vkui:relative vkui:flex vkui:w-px vkui:items-center vkui:justify-center vkui:after:absolute vkui:after:inset-y-0 vkui:after:left-1/2 vkui:after:w-1 vkui:after:-translate-x-1/2 vkui:focus-visible:ring-1 vkui:focus-visible:ring-offset-1 focus-visible:outline-hidden vkui:data-[panel-group-direction=vertical]:h-px vkui:data-[panel-group-direction=vertical]:w-full vkui:data-[panel-group-direction=vertical]:after:left-0 vkui:data-[panel-group-direction=vertical]:after:h-1 vkui:data-[panel-group-direction=vertical]:after:w-full vkui:data-[panel-group-direction=vertical]:after:-translate-y-1/2 vkui:data-[panel-group-direction=vertical]:after:translate-x-0 vkui:[&[data-panel-group-direction=vertical]>div]:rotate-90",
        direction === "vertical"
          ? "vkui:cursor-row-resize"
          : "vkui:cursor-col-resize",
        className,
      )}
      {...props}
    >
      {withHandle && (
        <div className="vkui:border-transparent vkui:z-10 vkui:flex vkui:h-8 vkui:w-4 vkui:items-center vkui:justify-center vkui:rounded-xs vkui:border vkui:text-subtle vkui:hover:text-foreground vkui:focus:text-foreground">
          <EllipsisVerticalIcon size={16} />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  );
}

export {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
  ResizablePrimitive,
};



================================================
FILE: src/components/ui/select.stories.tsx
================================================
import {
  Select,
  SelectContent,
  SelectGuide,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { Story, StoryDefault } from "@ladle/react";

export default {
  title: "Primitives",
} satisfies StoryDefault;

export const SelectDefault: Story<{
  guide?: string;
  size: "default" | "sm";
}> = ({ guide, size }) => (
  <Select>
    <SelectTrigger size={size}>
      {guide && <SelectGuide>{guide}</SelectGuide>}
      <SelectValue placeholder="Please select" />
    </SelectTrigger>
    <SelectContent>
      <SelectItem value="item-1">Select Item 1</SelectItem>
      <SelectItem value="item-2">Select Item 2</SelectItem>
      <SelectItem value="item-3">Select Item 3</SelectItem>
    </SelectContent>
  </Select>
);

SelectDefault.args = {
  guide: "",
};
SelectDefault.argTypes = {
  size: {
    options: ["default", "sm", "lg"],
    control: { type: "radio" },
    defaultValue: "default",
  },
};

SelectDefault.storyName = "Select";



================================================
FILE: src/components/ui/select.tsx
================================================
import * as SelectPrimitive from "@radix-ui/react-select";
import * as React from "react";

import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  SelectChevronIcon,
} from "@/icons";
import { getPipecatUIContainer } from "@/lib/dom";
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const selectTriggerVariants = cva(
  "vkui:border-input vkui:text-foreground vkui:data-[placeholder]:text-muted-foreground vkui:font-mono vkui:text-xs vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:aria-invalid:ring-destructive/20 vkui:dark:aria-invalid:ring-destructive/40 vkui:aria-invalid:border-destructive vkui:dark:bg-input/30 vkui:dark:hover:bg-input/50 vkui:flex w-fit vkui:items-center vkui:justify-between vkui:rounded-element vkui:border vkui:bg-transparent vkui:whitespace-nowrap vkui:transition-[color,box-shadow] vkui:outline-none vkui:focus-visible:ring-[3px] vkui:disabled:cursor-not-allowed vkui:disabled:opacity-50 vkui:*:data-[slot=select-value]:line-clamp-1 vkui:*:data-[slot=select-value]:flex vkui:*:data-[slot=select-value]:items-center vkui:*:data-[slot=select-value]:gap-2 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "",
        ghost: "vkui:border-none  vkui:hover:bg-accent",
      },
      size: {
        default:
          "vkui:h-8 vkui:pl-3 vkui:pr-2.5 vkui:py-2 vkui:gap-2 vkui:[&_svg]:size-3.5",
        sm: "vkui:h-7 vkui:pl-3 vkui:pr-2.5 vkui:py-1.5 vkui:gap-2 vkui:[&_svg]:size-3.5",
        lg: "vkui:h-10 vkui:px-3.5 vkui:py-2.5 vkui:gap-3 vkui:[&_svg]:size-4",
      },
    },
    defaultVariants: {
      size: "default",
      variant: "default",
    },
  },
);

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  variant = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> &
  VariantProps<typeof selectTriggerVariants>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        selectTriggerVariants({ size, variant }),
        "vkui:truncate",
        className,
      )}
      {...props}
    >
      <span className="vkui:truncate vkui:flex-1 vkui:min-w-0">{children}</span>
      <SelectPrimitive.Icon asChild>
        <SelectChevronIcon className="vkui:opacity-50 vkui:flex-none" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectGuide({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="select-guide"
      className={cn("vkui:text-subtle vkui:font-sans", className)}
      {...props}
    />
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal container={getPipecatUIContainer()}>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "vkui:bg-popover vkui:text-popover-foreground vkui:data-[state=open]:animate-in vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=open]:fade-in-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[state=open]:zoom-in-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:relative vkui:z-50 vkui:max-h-(--radix-select-content-available-height) vkui:min-w-[8rem] vkui:origin-(--radix-select-content-transform-origin) vkui:overflow-x-hidden vkui:overflow-y-auto vkui:rounded-md vkui:border vkui:shadow-md",
          position === "popper" &&
            "vkui:data-[side=bottom]:translate-y-1 vkui:data-[side=left]:-translate-x-1 vkui:data-[side=right]:translate-x-1 vkui:data-[side=top]:-translate-y-1",
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "vkui:p-1",
            position === "popper" &&
              "vkui:h-[var(--radix-select-trigger-height)] vkui:w-full vkui:min-w-[var(--radix-select-trigger-width)] vkui:scroll-my-1",
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "vkui:focus:bg-accent vkui:focus:text-accent-foreground vkui:[&_svg:not([class*='text-'])]:text-muted-foreground vkui:relative vkui:flex vkui:w-full vkui:cursor-default vkui:items-center vkui:gap-2 vkui:rounded-sm vkui:py-1.5 vkui:pr-8 vkui:pl-2 vkui:text-sm vkui:outline-hidden vkui:select-none vkui:data-[disabled]:pointer-events-none vkui:data-[disabled]:opacity-50 [&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 vkui:[&_svg:not([class*='size-'])]:size-4 vkui:*:[span]:last:flex vkui:*:[span]:last:items-center vkui:*:[span]:last:gap-2",
        className,
      )}
      {...props}
    >
      <span className="vkui:absolute vkui:right-2 vkui:flex vkui:size-3.5 vkui:items-center vkui:justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn(
        "vkui:bg-border vkui:pointer-events-none vkui:-mx-1 vkui:my-1 vkui:h-px",
        className,
      )}
      {...props}
    />
  );
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "vkui:flex vkui:cursor-default vkui:items-center vkui:justify-center vkui:py-1",
        className,
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "vkui:flex vkui:cursor-default vkui:items-center vkui:justify-center vkui:py-1",
        className,
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectGuide,
  SelectItem,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};



================================================
FILE: src/components/ui/tabs.tsx
================================================
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "@/lib/utils";

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("vkui:flex vkui:flex-col vkui:gap-2", className)}
      {...props}
    />
  );
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "vkui:bg-muted vkui:text-muted-foreground vkui:inline-flex vkui:h-10 vkui:p-1 vkui:w-fit vkui:items-center vkui:justify-center vkui:rounded-md p-[3px] vkui:gap-1",
        className,
      )}
      {...props}
    />
  );
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "vkui:data-[state=active]:bg-background vkui:data-[state=active]:text-foreground vkui:focus-visible:border-ring vkui:focus-visible:ring-ring/50 vkui:focus-visible:outline-ring vkui:hover:bg-muted-foreground/10 vkui:text-foreground vkui:inline-flex vkui:h-[calc(100%-1px)] vkui:flex-1 vkui:items-center vkui:justify-center vkui:gap-1.5 vkui:rounded-sm vkui:border vkui:border-transparent vkui:px-2 vkui:py-1 vkui:text-xs vkui:font-bold vkui:whitespace-nowrap vkui:transition-[color,box-shadow] vkui:focus-visible:ring-[3px] vkui:focus-visible:outline-1 vkui:disabled:pointer-events-none vkui:disabled:opacity-50 vkui:[&_svg]:pointer-events-none vkui:[&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 vkui:mono-upper",
        className,
      )}
      {...props}
    />
  );
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      forceMount
      className={cn(
        "vkui:flex-1 vkui:outline-none vkui:data-[state=inactive]:hidden",
        className,
      )}
      {...props}
    />
  );
}

export { Tabs, TabsContent, TabsList, TabsTrigger };



================================================
FILE: src/components/ui/tooltip.tsx
================================================
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import * as React from "react";

import { cn } from "@/lib/utils";
import { getPipecatUIContainer } from "@/lib/dom";

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal container={getPipecatUIContainer()}>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "vkui:bg-primary vkui:text-primary-foreground vkui:animate-in vkui:fade-in-0 vkui:zoom-in-95 vkui:data-[state=closed]:animate-out vkui:data-[state=closed]:fade-out-0 vkui:data-[state=closed]:zoom-out-95 vkui:data-[side=bottom]:slide-in-from-top-2 vkui:data-[side=left]:slide-in-from-right-2 vkui:data-[side=right]:slide-in-from-left-2 vkui:data-[side=top]:slide-in-from-bottom-2 vkui:z-50 vkui:w-fit vkui:origin-(--radix-tooltip-content-transform-origin) vkui:rounded-md vkui:px-3 vkui:py-1.5 vkui:text-xs vkui:text-balance",
          className,
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="vkui:bg-primary vkui:fill-primary vkui:z-50 vkui:size-2.5 vkui:translate-y-[calc(-50%_-_2px)] vkui:rotate-45 vkui:rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };



================================================
FILE: src/hooks/index.ts
================================================
export { useConversation } from "./useConversation";



================================================
FILE: src/hooks/useConversation.ts
================================================
import { RTVIEvent } from "@pipecat-ai/client-js";
import { useRTVIClientEvent } from "@pipecat-ai/client-react";
import { useRef, useState } from "react";

interface ConversationMessage {
  role: "user" | "assistant";
  content: string;
  final?: boolean;
  createdAt: string;
  updatedAt?: string;
}

interface Props {
  onMessageAdded?: (message: ConversationMessage) => void;
}

const sortByCreatedAt = (
  a: ConversationMessage,
  b: ConversationMessage,
): number => {
  return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
};

const filterEmptyMessages = (
  message: ConversationMessage,
  index: number,
  array: ConversationMessage[],
): boolean => {
  if (message.content) return true;

  // For empty messages, check if there's a non-empty message with the same role following it
  const nextMessageWithSameRole = array
    .slice(index + 1)
    .find((m) => m.role === message.role && m.content);

  return !nextMessageWithSameRole;
};

export const useConversation = ({ onMessageAdded }: Props = {}) => {
  const [messages, setMessages] = useState<ConversationMessage[]>([]);

  useRTVIClientEvent(RTVIEvent.Connected, () => {
    setMessages([]);
  });

  useRTVIClientEvent(RTVIEvent.BotLlmStarted, () => {
    const now = new Date();
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant",
      );
      const lastBotMessage = prev[lastBotMessageIndex];
      if (
        lastBotMessage &&
        lastBotMessage.role === "assistant" &&
        !lastBotMessage.content
      ) {
        return prev.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage: ConversationMessage = {
        role: "assistant",
        content: "",
        final: false,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString(),
      };
      onMessageAdded?.(newMessage);
      return [...prev, newMessage]
        .sort(sortByCreatedAt)
        .filter(filterEmptyMessages);
    });
  });

  useRTVIClientEvent(RTVIEvent.BotLlmText, (data) => {
    const now = new Date();
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant",
      );
      const lastBotMessage = prev[lastBotMessageIndex];

      if (!lastBotMessage) {
        const newMessage: ConversationMessage = {
          role: "assistant",
          content: data.text,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
        };
        onMessageAdded?.(newMessage);
        return [...prev, newMessage]
          .sort(sortByCreatedAt)
          .filter(filterEmptyMessages);
      }

      // Bump potential empty last message
      if (!lastBotMessage.content) {
        const newMessages = prev.slice();
        newMessages.splice(lastBotMessageIndex, 1, {
          ...lastBotMessage,
          content: data.text,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }

      const isRecent =
        lastBotMessage &&
        lastBotMessage.role === "assistant" &&
        now.getTime() - new Date(lastBotMessage.createdAt).getTime() < 10000; // 10 seconds threshold

      if (isRecent) {
        const newMessages = prev.slice();
        newMessages.splice(lastBotMessageIndex, 1, {
          ...lastBotMessage,
          content: lastBotMessage.content + data.text,
          createdAt: lastBotMessage.content
            ? lastBotMessage.createdAt
            : now.toISOString(),
          updatedAt: now.toISOString(),
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }

      const newMessage: ConversationMessage = {
        role: "assistant",
        content: data.text,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString(),
      };

      onMessageAdded?.(newMessage);
      return [...prev, newMessage]
        .sort(sortByCreatedAt)
        .filter(filterEmptyMessages);
    });
  });

  useRTVIClientEvent(RTVIEvent.BotLlmStopped, () => {
    setMessages((prev) => {
      const lastBotMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "assistant",
      );
      const lastBotMessage = prev[lastBotMessageIndex];
      if (!lastBotMessage) return prev;
      if (
        lastBotMessage &&
        lastBotMessage.role === "assistant" &&
        !lastBotMessage.content
      ) {
        return prev
          .slice(0, -1)
          .sort(sortByCreatedAt)
          .filter(filterEmptyMessages);
      }
      lastBotMessage.final = true;
      const newMessages = prev.slice();
      newMessages.splice(lastBotMessageIndex, 1, {
        ...lastBotMessage,
        updatedAt: new Date().toISOString(),
      });
      onMessageAdded?.(lastBotMessage);
      return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
    });
  });

  const userStoppedTimeout = useRef<ReturnType<typeof setTimeout>>(undefined);

  useRTVIClientEvent(RTVIEvent.UserStartedSpeaking, () => {
    clearTimeout(userStoppedTimeout.current);
    const now = new Date();
    setMessages((prev) => {
      const lastUserMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "user",
      );
      const lastUserMessage = prev[lastUserMessageIndex];
      if (
        lastUserMessage &&
        lastUserMessage.role === "user" &&
        !lastUserMessage.content
      ) {
        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1, {
          ...lastUserMessage,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
        });
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage: ConversationMessage = {
        role: "user",
        content: "",
        final: false,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString(),
      };
      onMessageAdded?.(newMessage);
      return [...prev, newMessage]
        .sort(sortByCreatedAt)
        .filter(filterEmptyMessages);
    });
  });

  useRTVIClientEvent(RTVIEvent.UserTranscript, (data) => {
    const now = new Date();
    setMessages((prev) => {
      const lastUserMessageIndex = prev.findLastIndex(
        (msg) => msg.role === "user",
      );
      const lastUserMessage = prev[lastUserMessageIndex];
      if (lastUserMessage && !lastUserMessage.final) {
        const updatedMessage: ConversationMessage = {
          ...lastUserMessage,
          final: data.final,
          content: data.text,
          updatedAt: now.toISOString(),
        };
        onMessageAdded?.(updatedMessage);
        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1, updatedMessage);
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      }
      const newMessage: ConversationMessage = {
        role: "user",
        content: data.text,
        final: data.final,
        createdAt: now.toISOString(),
      };
      onMessageAdded?.(newMessage);
      return [...prev, newMessage]
        .sort(sortByCreatedAt)
        .filter(filterEmptyMessages);
    });
  });

  useRTVIClientEvent(RTVIEvent.UserStoppedSpeaking, () => {
    clearTimeout(userStoppedTimeout.current);
    userStoppedTimeout.current = setTimeout(() => {
      setMessages((prev) => {
        const lastUserMessageIndex = prev.findLastIndex(
          (msg) => msg.role === "user",
        );
        const lastUserMessage = prev[lastUserMessageIndex];

        if (!lastUserMessage || lastUserMessage.content)
          return prev.sort(sortByCreatedAt).filter(filterEmptyMessages);

        const newMessages = prev.slice();
        newMessages.splice(lastUserMessageIndex, 1);
        return newMessages.sort(sortByCreatedAt).filter(filterEmptyMessages);
      });
    }, 5000);
  });

  // Merge messages of the same role that are close in time (within 30 seconds)
  const getMergedMessages = () => {
    const mergedMessages: ConversationMessage[] = [];

    for (let i = 0; i < messages.length; i++) {
      const currentMessage = messages[i];
      const lastMerged = mergedMessages[mergedMessages.length - 1];

      const timeDiff = lastMerged
        ? Math.abs(
            new Date(currentMessage.createdAt).getTime() -
              new Date(lastMerged.createdAt).getTime(),
          )
        : Infinity;

      const shouldMerge =
        lastMerged &&
        lastMerged.role === currentMessage.role &&
        timeDiff < 30000; // 30 seconds threshold

      if (shouldMerge) {
        mergedMessages[mergedMessages.length - 1] = {
          ...lastMerged,
          content: `${lastMerged.content} ${currentMessage.content}`,
          updatedAt: currentMessage.updatedAt || currentMessage.createdAt,
          final: currentMessage.final !== false,
        };
      } else {
        mergedMessages.push({ ...currentMessage });
      }
    }

    return mergedMessages;
  };

  return {
    messages: getMergedMessages(),
  };
};
export default useConversation;



================================================
FILE: src/hooks/useTheme.ts
================================================
import { useContext } from "react";
import { ThemeProviderContext } from "../components/ThemeProviderContext";

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider");

  return context;
};



================================================
FILE: src/lib/dom.ts
================================================
export function getPipecatUiNamespace(): string {
  return ".voice-ui-kit";
}

export function getPipecatUIContainer(): HTMLElement {
  return document.querySelector(getPipecatUiNamespace()) ?? document.body;
}



================================================
FILE: src/lib/utils.ts
================================================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



================================================
FILE: src/templates/index.ts
================================================
export { ConsoleTemplate } from "./Console";



================================================
FILE: src/templates/Console/Console.stories.tsx
================================================
import { FullScreenContainer } from "@/components/ui";
import type { StoryDefault } from "@ladle/react";
import { ConsoleTemplate } from "./index";

export default {
  title: "Templates / Console",
} satisfies StoryDefault;

export const Default = () => (
  <FullScreenContainer>
    <ConsoleTemplate
      transportType="smallwebrtc"
      connectParams={{
        connectionUrl: "http://localhost:7860/api/offer",
      }}
      noUserVideo={true}
    />
  </FullScreenContainer>
);
Default.meta = { iframed: false };



================================================
FILE: src/templates/Console/index.tsx
================================================
"use client";

import AudioOutput from "@/components/elements/AudioOutput";
import { ClientStatus } from "@/components/elements/ClientStatus";
import ConnectButton from "@/components/elements/ConnectButton";
import PipecatLogo from "@/components/elements/PipecatLogo";
import { SessionInfo } from "@/components/elements/SessionInfo";
import UserAudioControl from "@/components/elements/UserAudioControl";
import UserVideoControl from "@/components/elements/UserVideoControl";
import { BotAudioPanel } from "@/components/panels/BotAudioPanel";
import { BotVideoPanel } from "@/components/panels/BotVideoPanel";
import ConversationPanel from "@/components/panels/ConversationPanel";
import { EventsPanel } from "@/components/panels/EventsPanel";
import { InfoPanel } from "@/components/panels/InfoPanel";
import ThemeModeToggle from "@/components/ThemeModeToggle";
import {
  Banner,
  BannerClose,
  BannerIcon,
  BannerTitle,
} from "@/components/ui/banner";
import { Button } from "@/components/ui/button";
import { LoaderSpinner } from "@/components/ui/loaders";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  BotIcon,
  ChevronsLeftRightEllipsisIcon,
  CircleAlertIcon,
  InfoIcon,
  MessagesSquareIcon,
  MicIcon,
  PanelLeftCloseIcon,
  PanelRightCloseIcon,
} from "@/icons";
import { cn } from "@/lib/utils";
import {
  type ConnectionEndpoint,
  PipecatClient,
  type PipecatClientOptions,
  type TransportConnectionParams,
} from "@pipecat-ai/client-js";
import {
  PipecatClientAudio,
  PipecatClientProvider,
} from "@pipecat-ai/client-react";
import {
  DailyTransport,
  type DailyTransportConstructorOptions,
} from "@pipecat-ai/daily-transport";
import {
  SmallWebRTCTransport,
  type SmallWebRTCTransportConstructorOptions,
} from "@pipecat-ai/small-webrtc-transport";
import React, { useEffect, useRef, useState } from "react";
import type { ImperativePanelHandle } from "react-resizable-panels";

export interface ConsoleTemplateProps {
  /**
   * Sets the audio codec. Only applicable for SmallWebRTC transport.
   * Defaults to "default" which uses the browser's default codec.
   */
  audioCodec?: string;
  /**
   * Options for configuring the RTVI client.
   */
  clientOptions?: Partial<PipecatClientOptions>;
  /**
   * Options for configuring the transport.
   */
  transportOptions?:
    | SmallWebRTCTransportConstructorOptions
    | DailyTransportConstructorOptions;
  /**
   * Parameters for connecting to the transport.
   */
  connectParams?: TransportConnectionParams | ConnectionEndpoint;
  /**
   * Disables audio output for the bot. The bot may still send audio, but it won't be played.
   */
  noAudioOutput?: boolean;
  /**
   * Disables audio visualization for the bot.
   * The bot may still send audio, but it won't be visualized.
   */
  noBotAudio?: boolean;
  /**
   * Disables video visualization for the bot.
   * The bot may still send video, but it won't be displayed.
   */
  noBotVideo?: boolean;
  /**
   * Disables the conversation panel.
   * The bot may still send messages, but they won't be displayed.
   */
  noConversation?: boolean;
  /**
   * Disables the logo in the header.
   */
  noLogo?: boolean;
  /**
   * Disables the metrics panel.
   * The bot may still send metrics, but they won't be displayed.
   */
  noMetrics?: boolean;
  /**
   * Disables the session info panel.
   */
  noSessionInfo?: boolean;
  /**
   * Disables the status info panel.
   */
  noStatusInfo?: boolean;
  /**
   * Disables the theme switcher in the header.
   * Useful when there's an application-level theme switcher or when the theme is controlled globally.
   */
  noThemeSwitch?: boolean;
  /**
   * Disables user audio input entirely.
   */
  noUserAudio?: boolean;
  /**
   * Disables user video input entirely.
   */
  noUserVideo?: boolean;
  /**
   * Title displayed in the header.
   * Defaults to "Pipecat Playground".
   */
  title?: string;
  /**
   * Type of transport to use for the RTVI client.
   * - "daily" for Daily Transport
   * - "smallwebrtc" for SmallWebRTC Transport
   * Defaults to "daily".
   */
  transportType?: "daily" | "smallwebrtc";
  /**
   * Sets the video codec. Only applicable for SmallWebRTC transport.
   * Defaults to "default" which uses the browser's default codec.
   */
  videoCodec?: string;

  /**
   * Whether to collapse the info panel by default.
   * When true, the info panel will be collapsed on initial render.
   */
  collapseInfoPanel?: boolean;
  /**
   * Custom logo component to display in the header.
   * If provided, this will replace the default Pipecat logo.
   * Accepts any valid React element.
   */
  logoComponent?: React.ReactNode;
}

const defaultClientOptions: Partial<PipecatClientOptions> = {};
const defaultTransportOptions:
  | Partial<SmallWebRTCTransportConstructorOptions>
  | Partial<DailyTransportConstructorOptions> = {};

export const ConsoleTemplate: React.FC<ConsoleTemplateProps> = ({
  audioCodec = "default",
  clientOptions = defaultClientOptions,
  transportOptions = defaultTransportOptions,
  connectParams,
  noAudioOutput = false,
  noBotAudio = false,
  noBotVideo = false,
  noConversation = false,
  noLogo = false,
  noMetrics = false,
  noSessionInfo = false,
  noStatusInfo = false,
  noThemeSwitch = false,
  noUserAudio = false,
  noUserVideo = false,
  title = "Pipecat Playground",
  transportType = "daily",
  videoCodec = "default",
  collapseInfoPanel = false,
  logoComponent,
}) => {
  const [isBotAreaCollapsed, setIsBotAreaCollapsed] = useState(false);
  const [isInfoPanelCollapsed, setIsInfoPanelCollapsed] = useState(false);
  const [isEventsPanelCollapsed, setIsEventsPanelCollapsed] = useState(false);
  const [sessionId, setSessionId] = useState("");
  const [participantId, setParticipantId] = useState("");
  const [client, setClient] = useState<PipecatClient | null>(null);
  const [isClientReady, setIsClientReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const infoPanelRef = useRef<ImperativePanelHandle>(null);

  useEffect(
    function initClient() {
      // Only run on client side
      if (typeof window === "undefined") return;

      let transport: DailyTransport | SmallWebRTCTransport;
      switch (transportType) {
        case "smallwebrtc":
          transport = new SmallWebRTCTransport(
            transportOptions as SmallWebRTCTransportConstructorOptions,
          );
          break;
        case "daily":
        default:
          transport = new DailyTransport(
            transportOptions as DailyTransportConstructorOptions,
          );
          transport.dailyCallClient.on("meeting-session-updated", (event) => {
            setSessionId(event.meetingSession.id);
          });
          break;
      }
      const pcClient = new PipecatClient({
        enableCam: !noUserVideo,
        enableMic: !noUserAudio,
        ...clientOptions,
        transport: clientOptions?.transport ?? transport,
        callbacks: {
          onParticipantJoined: (participant) => {
            setParticipantId(participant.id || "");
            clientOptions?.callbacks?.onParticipantJoined?.(participant);
          },
          onTrackStarted(track, participant) {
            if (participant?.id && participant.local)
              setParticipantId(participant.id);
            clientOptions?.callbacks?.onTrackStarted?.(track, participant);
          },
        },
      });
      pcClient.initDevices();
      setClient(pcClient);
      setIsClientReady(true);
      return () => {
        /**
         * Disconnect client when component unmounts or options change.
         */
        pcClient.disconnect();
      };
    },
    [clientOptions, transportOptions, noUserAudio, noUserVideo, transportType],
  );

  useEffect(
    function updateSmallWebRTCCodecs() {
      if (!client || transportType !== "smallwebrtc") return;
      const transport = client.transport as SmallWebRTCTransport;
      if (audioCodec) {
        transport.setAudioCodec(audioCodec);
      }
      if (videoCodec) {
        transport.setVideoCodec(videoCodec);
      }
    },
    [audioCodec, client, videoCodec, transportType],
  );

  const handleConnect = async () => {
    if (!client) return;
    setError(null);
    try {
      await client.connect(connectParams);
    } catch (error) {
      setError(error instanceof Error ? error.message : "Unknown error");
      await client.disconnect();
    }
  };

  const handleDisconnect = async () => {
    if (!client) return;
    setError(null);
    await client.disconnect();
  };

  // Return loading state until client is ready (prevents hydration mismatch)
  if (!isClientReady || !client) {
    return (
      <div className="vkui:flex vkui:items-center vkui:justify-center vkui:h-full vkui:w-full">
        <LoaderSpinner />
      </div>
    );
  }

  const noBotArea = noBotAudio && noBotVideo;
  const noConversationPanel = noConversation && noMetrics;
  const noDevices = noAudioOutput && noUserAudio && noUserVideo;
  const noInfoPanel = noStatusInfo && noDevices && noSessionInfo;

  return (
    <PipecatClientProvider client={client}>
      {error && (
        <Banner
          variant="destructive"
          className="vkui:animate-in vkui:fade-in vkui:duration-300"
        >
          <BannerIcon icon={CircleAlertIcon} />
          <BannerTitle>
            Unable to connect. Please check web console for errors.
          </BannerTitle>
          <BannerClose variant="destructive" />
        </Banner>
      )}
      <div className="vkui:grid vkui:grid-cols-1 vkui:grid-rows-[min-content_1fr] vkui:sm:grid-rows-[min-content_1fr_auto] vkui:h-full vkui:w-full vkui:overflow-auto">
        <div className="vkui:grid vkui:grid-cols-2 vkui:sm:grid-cols-[150px_1fr_150px] vkui:gap-2 vkui:items-center vkui:justify-center vkui:p-2 vkui:bg-background vkui:sm:relative vkui:top-0 vkui:w-full vkui:z-10">
          {noLogo ? (
            <span className="vkui:h-6" />
          ) : (
            (logoComponent ?? (
              <PipecatLogo className="vkui:h-6 vkui:w-auto vkui:text-foreground" />
            ))
          )}
          <strong className="vkui:hidden vkui:sm:block vkui:text-center">
            {title}
          </strong>
          <div className="vkui:flex vkui:items-center vkui:justify-end vkui:gap-2 vkui:sm:gap-3 vkui:xl:gap-6">
            <div className="vkui:flex vkui:items-center vkui:gap-1">
              {!noThemeSwitch && <ThemeModeToggle />}
              <Button
                className="vkui:hidden vkui:sm:flex"
                variant={"ghost"}
                isIcon
                onClick={() => {
                  if (isInfoPanelCollapsed) {
                    infoPanelRef.current?.expand();
                  } else {
                    infoPanelRef.current?.collapse();
                  }
                }}
              >
                {isInfoPanelCollapsed ? (
                  <PanelLeftCloseIcon />
                ) : (
                  <PanelRightCloseIcon />
                )}
              </Button>
            </div>
            <ConnectButton
              onConnect={handleConnect}
              onDisconnect={handleDisconnect}
            />
          </div>
        </div>
        <div className="vkui:hidden vkui:sm:block">
          <ResizablePanelGroup direction="vertical" className="vkui:h-full">
            <ResizablePanel defaultSize={70} minSize={50}>
              <ResizablePanelGroup direction="horizontal">
                {!noBotArea && (
                  <>
                    <ResizablePanel
                      className="vkui:flex vkui:flex-col vkui:gap-2 vkui:p-2 vkui:xl:gap-4"
                      defaultSize={26}
                      maxSize={30}
                      minSize={10}
                      collapsible
                      collapsedSize={8}
                      onCollapse={() => setIsBotAreaCollapsed(true)}
                      onExpand={() => setIsBotAreaCollapsed(false)}
                    >
                      {!noBotAudio && (
                        <BotAudioPanel
                          className={cn({
                            "vkui:mb-auto": noBotVideo,
                          })}
                          collapsed={isBotAreaCollapsed}
                        />
                      )}
                      {!noBotVideo && (
                        <BotVideoPanel
                          className={cn({
                            "vkui:mt-auto": noBotAudio,
                          })}
                          collapsed={isBotAreaCollapsed}
                        />
                      )}
                    </ResizablePanel>
                    {(!noConversationPanel || !noInfoPanel) && (
                      <ResizableHandle withHandle />
                    )}
                  </>
                )}
                {!noConversationPanel && (
                  <>
                    <ResizablePanel
                      className="vkui:h-full vkui:p-2"
                      defaultSize={collapseInfoPanel ? 70 : 47}
                      minSize={30}
                    >
                      <ConversationPanel
                        noConversation={noConversation}
                        noMetrics={noMetrics}
                      />
                    </ResizablePanel>
                    {!noInfoPanel && <ResizableHandle withHandle />}
                  </>
                )}
                {!noInfoPanel && (
                  <ResizablePanel
                    id="info-panel"
                    ref={infoPanelRef}
                    collapsible
                    collapsedSize={4}
                    defaultSize={collapseInfoPanel ? 4 : 27}
                    minSize={15}
                    onCollapse={() => setIsInfoPanelCollapsed(true)}
                    onExpand={() => setIsInfoPanelCollapsed(false)}
                    className="vkui:p-2"
                  >
                    {isInfoPanelCollapsed ? (
                      <div className="vkui:flex vkui:flex-col vkui:items-center vkui:justify-center vkui:gap-4 vkui:h-full">
                        {!noStatusInfo && (
                          <Popover>
                            <PopoverTrigger asChild>
                              <Button variant="ghost" size="icon">
                                <ChevronsLeftRightEllipsisIcon size={16} />
                              </Button>
                            </PopoverTrigger>
                            <PopoverContent side="left">
                              <ClientStatus />
                            </PopoverContent>
                          </Popover>
                        )}
                        {!noDevices && (
                          <Popover>
                            <PopoverTrigger asChild>
                              <Button variant="ghost" size="icon">
                                <MicIcon size={16} />
                              </Button>
                            </PopoverTrigger>
                            <PopoverContent
                              className="vkui:flex vkui:flex-col vkui:gap-2"
                              side="left"
                            >
                              {!noUserAudio && <UserAudioControl />}
                              {!noUserVideo && <UserVideoControl />}
                              {!noAudioOutput && <AudioOutput />}
                            </PopoverContent>
                          </Popover>
                        )}
                        {!noSessionInfo && (
                          <Popover>
                            <PopoverTrigger asChild>
                              <Button variant="ghost" size="icon">
                                <InfoIcon size={16} />
                              </Button>
                            </PopoverTrigger>
                            <PopoverContent side="left">
                              <SessionInfo
                                sessionId={sessionId}
                                participantId={participantId}
                              />
                            </PopoverContent>
                          </Popover>
                        )}
                      </div>
                    ) : (
                      <InfoPanel
                        noAudioOutput={noAudioOutput}
                        noSessionInfo={noSessionInfo}
                        noStatusInfo={noStatusInfo}
                        noUserAudio={noUserAudio}
                        noUserVideo={noUserVideo}
                        participantId={participantId}
                        sessionId={sessionId}
                      />
                    )}
                  </ResizablePanel>
                )}
              </ResizablePanelGroup>
            </ResizablePanel>
            <ResizableHandle withHandle />
            <ResizablePanel
              collapsible
              collapsedSize={4}
              minSize={7}
              onCollapse={() => setIsEventsPanelCollapsed(true)}
              onExpand={() => setIsEventsPanelCollapsed(false)}
            >
              <EventsPanel collapsed={isEventsPanelCollapsed} />
            </ResizablePanel>
          </ResizablePanelGroup>
        </div>
        <Tabs
          defaultValue={
            noBotArea ? (noConversationPanel ? "info" : "conversation") : "bot"
          }
          className="vkui:flex vkui:flex-col vkui:gap-0 vkui:sm:hidden vkui:overflow-hidden"
        >
          <div className="vkui:flex vkui:flex-col vkui:overflow-hidden vkui:flex-1">
            {!noBotArea && (
              <TabsContent
                value="bot"
                className="vkui:flex-1 vkui:overflow-auto vkui:flex vkui:flex-col vkui:gap-4 vkui:p-2"
              >
                {!noBotAudio && <BotAudioPanel />}
                {!noBotVideo && <BotVideoPanel />}
              </TabsContent>
            )}
            {!noConversationPanel && (
              <TabsContent
                value="conversation"
                className="vkui:flex-1 vkui:overflow-auto"
              >
                <ConversationPanel
                  noConversation={noConversation}
                  noMetrics={noMetrics}
                />
              </TabsContent>
            )}
            <TabsContent
              value="info"
              className="vkui:flex-1 vkui:overflow-auto vkui:p-2"
            >
              <InfoPanel
                noAudioOutput={noAudioOutput}
                noUserAudio={noUserAudio}
                noUserVideo={noUserVideo}
                participantId={participantId}
                sessionId={sessionId}
              />
            </TabsContent>
            <TabsContent
              value="events"
              className="vkui:flex-1 vkui:overflow-auto"
            >
              <EventsPanel />
            </TabsContent>
          </div>
          <TabsList className="vkui:w-full vkui:h-12 vkui:rounded-none vkui:z-10 vkui:mt-auto vkui:shrink-0">
            {!noBotArea && (
              <TabsTrigger value="bot">
                <BotIcon />
              </TabsTrigger>
            )}
            {!noConversationPanel && (
              <TabsTrigger value="conversation">
                <MessagesSquareIcon />
              </TabsTrigger>
            )}
            <TabsTrigger value="info">
              <InfoIcon />
            </TabsTrigger>
            <TabsTrigger value="events">
              <ChevronsLeftRightEllipsisIcon />
            </TabsTrigger>
          </TabsList>
        </Tabs>
        {!noAudioOutput && <PipecatClientAudio />}
      </div>
    </PipecatClientProvider>
  );
};



================================================
FILE: src/visualizers/index.ts
================================================
export * from "./CircularWaveform";
export * from "./VoiceVisualizer";



================================================
FILE: src/visualizers/CircularWaveform/index.tsx
================================================
import { cn } from "@/lib/utils";
import { useCallback, useEffect, useRef } from "react";
import {
  type CanvasWaveformOptions,
  CircularWaveformCanvas,
  WaveformState,
} from "./canvas";

export interface CircularWaveformProps {
  size?: number;
  isThinking?: boolean;
  audioTrack?: MediaStreamTrack | null;
  className?: string;
  color1?: string;
  color2?: string;
  backgroundColor?: string;
  sensitivity?: number;
  rotationEnabled?: boolean;
  numBars?: number;
  barWidth?: number;
  debug?: boolean;
}

const CircularWaveform = ({
  size,
  audioTrack = null,
  isThinking = false,
  className = "",
  color1 = "#00D3F2",
  color2 = "#E12AFB",
  backgroundColor = "transparent",
  sensitivity = 1,
  rotationEnabled = true,
  numBars = 64,
  barWidth = 4,
  debug = false,
}: CircularWaveformProps) => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const waveformRef = useRef<CircularWaveformCanvas | null>(null);

  const getSize = useCallback((): { width: number; height: number } => {
    if (size) {
      return { width: size, height: size };
    }

    let containerWidth = window.innerWidth;
    let containerHeight = window.innerHeight;

    if (containerRef.current) {
      const containerRect = containerRef.current.getBoundingClientRect();
      containerWidth = containerRect.width;
      containerHeight = containerRect.height;
    }

    const availableSize = Math.min(containerWidth, containerHeight);
    const calculatedSize = availableSize;

    return { width: calculatedSize, height: calculatedSize };
  }, [size]);

  const determineState = useCallback((): WaveformState => {
    const newState = isThinking
      ? WaveformState.THINKING
      : audioTrack
        ? WaveformState.AUDIO
        : WaveformState.IDLE;

    return newState;
  }, [isThinking, audioTrack]);

  const initializeWaveform = useCallback(() => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const { width: canvasWidth, height: canvasHeight } = getSize();

    const options: CanvasWaveformOptions = {
      width: canvasWidth,
      height: canvasHeight,
      state: WaveformState.IDLE,
      color1,
      color2,
      backgroundColor,
      sensitivity,
      rotationEnabled,
      numBars,
      barWidth,
      debug,
    };

    // Create the waveform canvas
    const waveform = new CircularWaveformCanvas(canvas, options);

    // Store reference
    waveformRef.current = waveform;

    // Start visualization after a short delay
    setTimeout(() => {
      // Start the visualization
      waveform.startVisualization();

      // Apply the correct state based on props
      const currentState = determineState();
      waveform.setState(currentState);
    }, 100);
  }, [
    getSize,
    color1,
    color2,
    backgroundColor,
    sensitivity,
    rotationEnabled,
    numBars,
    barWidth,
    debug,
    determineState,
  ]);

  // Connect audio track if provided
  const connectAudioTrack = useCallback(() => {
    if (!waveformRef.current || !audioTrack) return;

    waveformRef.current.connectToAudioTrack(audioTrack);
  }, [audioTrack]);

  // Handle container resize using ResizeObserver
  useEffect(() => {
    if (!containerRef.current) return;

    const handleContainerResize = () => {
      if (!waveformRef.current || !canvasRef.current) return;

      const { width: canvasWidth, height: canvasHeight } = getSize();
      waveformRef.current.updateCanvasSize(canvasWidth, canvasHeight);
    };

    const resizeObserver = new ResizeObserver(() => {
      handleContainerResize();
    });

    resizeObserver.observe(containerRef.current);

    return () => {
      resizeObserver.disconnect();
    };
  }, [getSize]);

  // Initialize canvas on component mount
  useEffect(() => {
    initializeWaveform();
  }, [initializeWaveform]);

  // Connect audio track if provided
  useEffect(() => {
    if (audioTrack && waveformRef.current) {
      connectAudioTrack();
    }
  }, [audioTrack, connectAudioTrack]);

  // Update waveform state when relevant props change
  useEffect(() => {
    if (!waveformRef.current) return;

    const currentState = determineState();
    waveformRef.current.setState(currentState);
  }, [isThinking, audioTrack, determineState]);

  // Update waveform options when props change
  useEffect(() => {
    if (!waveformRef.current) return;

    waveformRef.current.updateOptions({
      color1,
      color2,
      backgroundColor,
      sensitivity,
      rotationEnabled,
      numBars,
      barWidth,
      debug,
    });
  }, [
    color1,
    color2,
    backgroundColor,
    sensitivity,
    rotationEnabled,
    numBars,
    barWidth,
    debug,
  ]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (waveformRef.current) {
        waveformRef.current.dispose();
      }
    };
  }, []);

  return (
    <div
      ref={containerRef}
      className={cn(
        "circular-waveform-container vkui:w-full vkui:h-full vkui:flex vkui:items-center vkui:justify-center",
        className,
      )}
      style={{ position: "relative" }}
    >
      <canvas ref={canvasRef} className="circular-waveform-canvas" />
    </div>
  );
};

CircularWaveform.displayName = "CircularWaveform";
export default CircularWaveform;



================================================
FILE: src/visualizers/VoiceVisualizer/index.tsx
================================================
import React, { useEffect, useRef } from "react";

import { usePipecatClientMediaTrack } from "@pipecat-ai/client-react";

type ParticipantType = Parameters<typeof usePipecatClientMediaTrack>[1];

interface Props {
  backgroundColor?: string;
  barColor?: string;
  barCount?: number;
  barGap?: number;
  barLineCap?: "round" | "square";
  barMaxHeight?: number;
  barOrigin?: "top" | "bottom" | "center";
  barWidth?: number;
  participantType: ParticipantType;
  className?: string;
}

export const VoiceVisualizer: React.FC<Props> = React.memo(
  ({
    backgroundColor = "transparent",
    barColor = "black",
    barCount = 5,
    barGap = 12,
    barLineCap = "round",
    barMaxHeight = 120,
    barOrigin = "center",
    barWidth = 30,
    participantType,
    className,
  }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const resolvedBarColorRef = useRef<string>("black");

    // Resolve the color only when barColor changes
    useEffect(() => {
      function resolveColor(color: string) {
        if (!color) return "black";
        if (color.startsWith("--")) {
          return (
            getComputedStyle(document.documentElement)
              .getPropertyValue(color)
              .trim() || "black"
          );
        }
        return color;
      }
      resolvedBarColorRef.current = resolveColor(barColor);
    }, [barColor]);

    const track: MediaStreamTrack | null = usePipecatClientMediaTrack(
      "audio",
      participantType,
    );

    useEffect(() => {
      if (!canvasRef.current) return;

      const canvasWidth = barCount * barWidth + (barCount - 1) * barGap;
      const canvasHeight = barMaxHeight;

      const canvas = canvasRef.current;

      const scaleFactor = 2;

      // Make canvas fill the width and height of its container
      const resizeCanvas = () => {
        canvas.width = canvasWidth * scaleFactor;
        canvas.height = canvasHeight * scaleFactor;

        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;

        canvasCtx.lineCap = barLineCap;
        canvasCtx.scale(scaleFactor, scaleFactor);
      };

      const canvasCtx = canvas.getContext("2d")!;
      resizeCanvas();

      if (!track) return;

      const audioContext = new AudioContext();
      const source = audioContext.createMediaStreamSource(
        new MediaStream([track]),
      );
      const analyser = audioContext.createAnalyser();

      analyser.fftSize = 1024;

      source.connect(analyser);

      const frequencyData = new Uint8Array(analyser.frequencyBinCount);

      canvasCtx.lineCap = barLineCap;

      // Create frequency bands based on barCount
      const bands = Array.from({ length: barCount }, (_, i) => {
        // Use improved logarithmic scale for better frequency distribution
        const minFreq = barCount > 20 ? 200 : 80; // Adjust min frequency based on bar count
        const maxFreq = 10000; // Cover most important audio frequencies

        // Use Mel scale inspired approach for more perceptually uniform distribution
        // This helps with a large number of bars by placing fewer in the very low range
        // https://en.wikipedia.org/wiki/Mel_scale
        const melMin = 2595 * Math.log10(1 + minFreq / 700);
        const melMax = 2595 * Math.log10(1 + maxFreq / 700);
        const melStep = (melMax - melMin) / barCount;

        const melValue = melMin + i * melStep;
        const startFreq = 700 * (Math.pow(10, melValue / 2595) - 1);
        const endFreq = 700 * (Math.pow(10, (melValue + melStep) / 2595) - 1);

        return {
          startFreq,
          endFreq,
          smoothValue: 0,
        };
      });

      const getFrequencyBinIndex = (frequency: number) => {
        const nyquist = audioContext.sampleRate / 2;
        return Math.round(
          (frequency / nyquist) * (analyser.frequencyBinCount - 1),
        );
      };

      function drawSpectrum() {
        analyser.getByteFrequencyData(frequencyData);
        canvasCtx.clearRect(
          0,
          0,
          canvas.width / scaleFactor,
          canvas.height / scaleFactor,
        );
        canvasCtx.fillStyle = backgroundColor;
        canvasCtx.fillRect(
          0,
          0,
          canvas.width / scaleFactor,
          canvas.height / scaleFactor,
        );

        let isActive = false;

        const totalBarsWidth =
          bands.length * barWidth + (bands.length - 1) * barGap;
        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;

        const adjustedCircleRadius = barWidth / 2;

        const resolvedBarColor = resolvedBarColorRef.current;

        bands.forEach((band, i) => {
          const startIndex = getFrequencyBinIndex(band.startFreq);
          const endIndex = getFrequencyBinIndex(band.endFreq);
          const bandData = frequencyData.slice(startIndex, endIndex);
          const bandValue =
            bandData.reduce((acc, val) => acc + val, 0) / bandData.length;

          const smoothingFactor = 0.2;

          if (bandValue < 1) {
            band.smoothValue = Math.max(
              band.smoothValue - smoothingFactor * 5,
              0,
            );
          } else {
            band.smoothValue =
              band.smoothValue +
              (bandValue - band.smoothValue) * smoothingFactor;
            isActive = true;
          }

          const x = startX + i * (barWidth + barGap);
          // Calculate bar height with a maximum cap
          const minHeight = 0;
          const barHeight = Math.max(
            minHeight,
            Math.min((band.smoothValue / 255) * barMaxHeight, barMaxHeight),
          );

          let yTop, yBottom;
          const canvasHeight = canvas.height / scaleFactor;

          switch (barOrigin) {
            case "top":
              yTop = adjustedCircleRadius;
              yBottom = Math.min(
                adjustedCircleRadius + barHeight,
                canvasHeight - adjustedCircleRadius,
              );
              break;
            case "bottom":
              yBottom = canvasHeight - adjustedCircleRadius;
              yTop = Math.max(yBottom - barHeight, adjustedCircleRadius);
              break;
            case "center":
            default:
              yTop = Math.max(
                canvasHeight / 2 - barHeight / 2,
                adjustedCircleRadius,
              );
              yBottom = Math.min(
                canvasHeight / 2 + barHeight / 2,
                canvasHeight - adjustedCircleRadius,
              );
              break;
          }

          if (band.smoothValue > 0) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(x + barWidth / 2, yTop);
            canvasCtx.lineTo(x + barWidth / 2, yBottom);
            canvasCtx.lineWidth = barWidth;
            canvasCtx.strokeStyle = resolvedBarColor;
            canvasCtx.stroke();
          } else {
            drawInactiveCircle(adjustedCircleRadius, resolvedBarColor, x, yTop);
          }
        });

        if (!isActive) {
          drawInactiveCircles(adjustedCircleRadius, resolvedBarColor);
        }

        requestAnimationFrame(drawSpectrum);
      }

      function drawInactiveCircle(
        circleRadius: number,
        color: string,
        x: number,
        y: number,
      ) {
        switch (barLineCap) {
          case "square":
            canvasCtx.fillStyle = color;
            canvasCtx.fillRect(
              x + barWidth / 2 - circleRadius,
              y - circleRadius,
              circleRadius * 2,
              circleRadius * 2,
            );
            break;
          case "round":
          default:
            canvasCtx.beginPath();
            canvasCtx.arc(x + barWidth / 2, y, circleRadius, 0, 2 * Math.PI);
            canvasCtx.fillStyle = color;
            canvasCtx.fill();
            canvasCtx.closePath();
            break;
        }
      }

      function drawInactiveCircles(circleRadius: number, color: string) {
        const totalBarsWidth =
          bands.length * barWidth + (bands.length - 1) * barGap;
        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
        const canvasHeight = canvas.height / scaleFactor;

        let y;
        switch (barOrigin) {
          case "top":
            y = circleRadius;
            break;
          case "bottom":
            y = canvasHeight - circleRadius;
            break;
          case "center":
          default:
            y = canvasHeight / 2;
            break;
        }

        bands.forEach((_, i) => {
          const x = startX + i * (barWidth + barGap);
          drawInactiveCircle(circleRadius, color, x, y);
        });
      }

      drawSpectrum();

      // Handle resizing
      window.addEventListener("resize", resizeCanvas);

      return () => {
        audioContext.close();
        window.removeEventListener("resize", resizeCanvas);
      };
    }, [
      backgroundColor,
      barCount,
      barGap,
      barLineCap,
      barMaxHeight,
      barOrigin,
      barWidth,
      track,
      barColor,
    ]);

    return (
      <canvas
        ref={canvasRef}
        style={{
          display: "block",
          width: "100%",
          height: "100%",
        }}
        className={className}
      />
    );
  },
);

VoiceVisualizer.displayName = "VoiceVisualizer";



================================================
FILE: src/visualizers/webgl/index.ts
================================================
export {
  default as Plasma,
  type PlasmaConfig,
  type PlasmaProps,
  type PlasmaRef,
} from "./Plasma";

export { PlasmaVisualizer } from "./PlasmaVisualizer";



================================================
FILE: src/visualizers/webgl/Plasma.tsx
================================================
import React, {
  forwardRef,
  memo,
  useCallback,
  useEffect,
  useImperativeHandle,
  useRef,
} from "react";
import * as THREE from "three";

// Configuration interfaces
interface PlasmaConfig {
  // Core plasma properties
  intensity?: number;
  radius?: number;
  effectScale?: number;
  effectCenter?: { x: number; y: number };
  blendMode?: 0 | 1 | 2 | 3 | 4 | 5;
  plasmaSpeed?: number;
  rayLength?: number;

  // Ring properties
  ringCount?: number;
  ringVisibility?: number;
  ringDistance?: number;
  ringSpread?: number;
  ringBounce?: number;
  ringThickness?: number;
  ringThicknessAudio?: number;
  ringVariance?: number;
  ringSharpness?: number;
  ringAmplitude?: number;
  ringSpeed?: number;
  ringSegments?: number;
  ringColorInheritance?: number;

  // Color properties
  useCustomColors?: boolean;
  color1?: string;
  color2?: string;
  color3?: string;
  backgroundColor?: string;
  colorCycleSpeed?: number;

  // Glow properties
  glowFalloff?: number;
  glowThreshold?: number;

  // Animation properties
  lerpSpeed?: number;
  audioLerpSpeed?: number;

  // Audio properties
  audioEnabled?: boolean;
  audioSensitivity?: number;
  audioSmoothing?: number;
  frequencyBands?: number;
  bassResponse?: number;
  midResponse?: number;
  trebleResponse?: number;
  plasmaVolumeReactivity?: number;
  volumeThreshold?: number;
}

export interface PlasmaProps {
  width?: number;
  height?: number;
  className?: string;
  style?: React.CSSProperties;
  initialConfig?: PlasmaConfig;
  onReady?: () => void;
  pixelRatio?: number;
  powerPreference?: "high-performance" | "low-power" | "default";
  alpha?: boolean;
  antialias?: boolean;
  preserveDrawingBuffer?: boolean;
  fallbackContent?: React.ReactNode;
  audioTrack?: MediaStreamTrack | null;
}

export interface PlasmaRef {
  updateConfig: (config: Partial<PlasmaConfig>) => void;
  getConfig: () => PlasmaConfig;
  resetToDefaults: () => void;
}

const vertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

const fragmentShader = `
    uniform vec2 iResolution;
    uniform float iTime;
    uniform float intensity;
    uniform float radius;
    uniform int blendMode;
    uniform float effectScale;
    uniform vec2 effectCenter;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;
    uniform bool useCustomColors;
    uniform float colorCycleSpeed;
    uniform float ringCount;
    uniform float ringVisibility;
    uniform float ringDistance;
    uniform float ringSpread;
    uniform float ringBounce;
    uniform float ringThickness;
    uniform float ringVariance;
    uniform float ringSharpness;
    uniform float ringAmplitude;
    uniform float ringSpeed;
    uniform float ringSegments;
    uniform float ringColorInheritance;
    uniform vec3 backgroundColor;
    uniform float plasmaSpeed;
    uniform float rayLength;
    uniform float glowFalloff;
    uniform float glowThreshold;
    varying vec2 vUv;
  
    #define TAU 6.2831852
    #define MOD3 vec3(.1031,.11369,.13787)
  
    vec3 blendColors(vec3 bg, vec3 fg, float amt, int mode) {
        if (mode == 0) return mix(bg, fg, amt);
        if (mode == 1) return clamp(bg + fg * amt, 0.0, 1.0);
        if (mode == 2) return 1.0 - (1.0 - bg) * (1.0 - fg * amt);
        if (mode == 3) {
            vec3 base = bg;
            vec3 blend = fg * amt;
            return vec3(
                (base.r < 0.5) ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),
                (base.g < 0.5) ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),
                (base.b < 0.5) ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))
            );
        }
        if (mode == 4) {
            vec3 base = bg;
            vec3 blend = fg * amt;
            return vec3(
                (blend.r < 0.5) ? (base.r - (1.0 - 2.0 * blend.r) * base.r * (1.0 - base.r)) : (base.r + (2.0 * blend.r - 1.0) * (sqrt(base.r) - base.r)),
                (blend.g < 0.5) ? (base.g - (1.0 - 2.0 * blend.g) * base.g * (1.0 - base.g)) : (base.g + (2.0 * blend.g - 1.0) * (sqrt(base.g) - base.g)),
                (blend.b < 0.5) ? (base.b - (1.0 - 2.0 * blend.b) * base.b * (1.0 - base.b)) : (base.b + (2.0 * blend.b - 1.0) * (sqrt(base.b) - base.b))
            );
        }
        if (mode == 5) return bg * (1.0 - amt) + fg * amt;
        return mix(bg, fg, amt);
    }
  
    vec3 hash33(vec3 p3) {
        p3 = fract(p3 * MOD3);
        p3 += dot(p3, p3.yxz+19.19);
        return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));
    }
  
    float simplex_noise(vec3 p) {
        const float K1 = 0.333333333;
        const float K2 = 0.166666667;
        
        vec3 i = floor(p + (p.x + p.y + p.z) * K1);
        vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);
            
        vec3 e = step(vec3(0.0), d0 - d0.yzx);
        vec3 i1 = e * (1.0 - e.zxy);
        vec3 i2 = 1.0 - e.zxy * (1.0 - e);
        
        vec3 d1 = d0 - (i1 - K2);
        vec3 d2 = d0 - (i2 - 2.0 * K2);
        vec3 d3 = d0 - (1.0 - 3.0 * K2);
        
        vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);
        vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));
        
        return dot(vec4(31.316), n);
    }
  
    vec3 getColor(vec2 uv, float t, float intensity) {
        float radius = length(uv);
        float angular1 = dot(uv, vec2(1.0, 0.0)) / (radius + 0.001);
        float angular2 = dot(uv, vec2(0.0, 1.0)) / (radius + 0.001);
        
        float phase1 = t * colorCycleSpeed + radius * 3.0 + intensity * 2.0;
        float phase2 = t * colorCycleSpeed * 0.7 + angular1 * 2.0 + intensity * 1.5;
        float phase3 = t * colorCycleSpeed * 1.3 + (radius + angular2) * 1.5;
        
        if (useCustomColors) {
            float band1 = sin(phase1) * 0.5 + 0.5;
            float band2 = sin(phase2 + 2.094) * 0.5 + 0.5; 
            float band3 = sin(phase3 + 4.189) * 0.5 + 0.5;
            
            band1 = pow(band1, 1.0 - intensity * 0.5);
            band2 = pow(band2, 1.0 - intensity * 0.3);
            band3 = pow(band3, 1.0 - intensity * 0.4);
            
            float sum = band1 + band2 + band3;
            return (color1 * band1 + color2 * band2 + color3 * band3) / sum;
        } else {
            vec3 rainbow = 0.5 + 0.5 * cos(phase1 + uv.xyx * 3.0 + vec3(0.0, 2.0, 4.0));
            vec3 rainbow2 = 0.5 + 0.5 * cos(phase2 + uv.yxy * 2.0 + vec3(1.0, 3.0, 5.0));
            return mix(rainbow, rainbow2, intensity);
        }
    }
  
    void main() {
        vec2 uv = (vUv * iResolution - iResolution.xy * 0.5) / iResolution.y;
        uv = (uv - effectCenter) / effectScale;
            
        float a = sin(atan(uv.y, uv.x));
        float am = abs(a - 0.5) * 0.25;
        float l = length(uv);                         
        
        float m1 = clamp(0.1 / smoothstep(0.0, radius, l), 0.0, 1.0);
        float m2 = clamp(0.1 / smoothstep(0.42, 0.0, l), 0.0, 1.0);
        
        float glowAttenuation = exp(-l * glowFalloff);
        m1 *= glowAttenuation;
        
        float s1 = simplex_noise(vec3(uv * 2.0, 1.0 + iTime * 0.525 * plasmaSpeed)) * max(1.0 - l * rayLength, 0.0) + 0.9;
        float s2 = simplex_noise(vec3(uv, 15.0 + iTime * 0.525 * plasmaSpeed)) * max(l, 0.025) + 1.25;
        float s3 = simplex_noise(vec3(vec2(am, am * 100.0 + iTime * 3.0 * plasmaSpeed) * 0.15, 30.0 + iTime * 0.525 * plasmaSpeed)) * max(l, 0.25) + 1.5;
        s3 *= smoothstep(0.0, 0.3345, l);    
        
        float sh = smoothstep(0.15, 0.35, l);
        float m = m1 * m1 * m2 * s1 * s2 * s3 * (1.0 - l) * sh * intensity;
        
        m = max(0.0, m - glowThreshold) / (1.0 - glowThreshold);
        
        float normalizedIntensity = clamp(m / intensity, 0.0, 1.0);
        vec3 colorVal = getColor(uv, iTime, normalizedIntensity);
        vec3 col = blendColors(backgroundColor, colorVal, m, blendMode);
        
        float angle = atan(uv.y, uv.x);
        float wave = iTime * ringSpeed;
        float pixelSize = 2.0 / iResolution.y;
        float thicknessFactor = ringThickness * ringThickness * 0.0001;
        float baseThickness = pixelSize * (1.0 + thicknessFactor * 99.0);
        float ringStart = 0.3;
        
        vec3 ringAccum = vec3(0.0);
        int numRings = int(ringCount);
        
        for (int i = 0; i < 5; i++) {
            if (i >= numRings) break;
            
            float ringIndex = float(i);
            float phaseOffset1 = ringIndex * 1.7 + ringVariance * sin(ringIndex * 3.14);
            float phaseOffset2 = ringIndex * 2.3 + ringVariance * cos(ringIndex * 2.71);
            float speedVariance = 1.0 + ringVariance * sin(ringIndex * 4.5) * 0.5;
            
            float normalizedAngle = angle * 0.159154943 + 0.5;
            float segmentsFloor = floor(ringSegments + 0.5);
            
            float wavePhase1 = sin(normalizedAngle * segmentsFloor * TAU + wave * speedVariance + phaseOffset1);
            float wavePhase2 = sin(normalizedAngle * floor(ringSegments * 1.5 + 0.5) * TAU - wave * speedVariance * 0.7 + phaseOffset2);
            float wavePhase3 = sin(normalizedAngle * floor(ringSegments * 0.5 + 0.5) * TAU + wave * speedVariance * 1.3 + ringIndex);
            
            float fractSegments = fract(ringSegments);
            if (fractSegments > 0.0) {
                float nextWavePhase1 = sin(normalizedAngle * floor(ringSegments + 1.5) * TAU + wave * speedVariance + phaseOffset1);
                wavePhase1 = mix(wavePhase1, nextWavePhase1, smoothstep(0.0, 1.0, fractSegments));
            }
            
            float combinedWave = mix(wavePhase1, wavePhase1 * 0.4 + wavePhase2 * 0.4 + wavePhase3 * 0.2, ringVariance);
            
            float baseRadius = ringStart + ringDistance + ringSpread * ringIndex * 0.2;
            if (ringBounce > 0.0) {
                baseRadius *= 1.0 + sin(iTime * 2.0 + ringIndex * 0.5) * ringBounce;
            }
            
            float ringRadius = baseRadius + ringAmplitude * combinedWave;
            float thicknessModulation = 1.0 + ringVariance * combinedWave * 0.3;
            float currentThickness = baseThickness * thicknessModulation;
            
            float ringDist = abs(l - ringRadius);
            float softEdge = smoothstep(currentThickness, currentThickness * 0.2, ringDist);
            float hardEdge = 1.0 - step(currentThickness * 0.5, ringDist);
            float ringMask = mix(softEdge, hardEdge, ringSharpness);
            
            float falloff = exp(-ringIndex * 0.3);
            float ringStrength = ringMask * ringVisibility * falloff;
            
            vec3 ringColor = vec3(1.0);
            if (useCustomColors) {
                float colorPhase = iTime * 0.3 + ringIndex * 0.7;
                vec3 originalRingColor = getColor(uv * 0.5, colorPhase, ringStrength);
                
                if (ringColorInheritance > 0.0) {
                    vec2 samplePos = normalize(uv) * ringRadius;
                    vec3 plasmaColor = getColor(samplePos, iTime, ringStrength);
                    ringColor = mix(originalRingColor, plasmaColor, ringColorInheritance);
                } else {
                    ringColor = originalRingColor;
                }
            }
            
            if (ringVariance > 0.0) {
                float noiseScale = 10.0 + ringIndex * 2.0;
                float ringNoise = simplex_noise(vec3(uv * noiseScale, iTime * 0.5 + ringIndex)) * 0.5 + 0.5;
                ringStrength *= mix(1.0, ringNoise, ringVariance * 0.5);
            }
            
            ringAccum += ringColor * ringStrength * 0.6;
        }
        
        col = clamp(col + ringAccum, 0.0, 1.5);
        gl_FragColor = vec4(col, 1.0);
    }
  `;

const defaultConfig: Required<PlasmaConfig> = {
  // Core plasma properties
  intensity: 1.5,
  radius: 1.85,
  effectScale: 0.5,
  effectCenter: { x: 0, y: 0 },
  blendMode: 0,
  plasmaSpeed: 1.0,
  rayLength: 1.0,

  // Ring properties
  ringCount: 3,
  ringVisibility: 0.6,
  ringDistance: 0.0,
  ringSpread: 0.07,
  ringBounce: 0.0,
  ringThickness: 12.0,
  ringThicknessAudio: 2.0,
  ringVariance: 0.64,
  ringSharpness: 1,
  ringAmplitude: 0.02,
  ringSpeed: 1.2,
  ringSegments: 5.4,
  ringColorInheritance: 1,

  // Color properties
  useCustomColors: true,
  color1: "#22d3ee",
  color2: "#34d399",
  color3: "#818cf8",
  backgroundColor: "transparent",
  colorCycleSpeed: 0.6,

  // Glow properties
  glowFalloff: 1.0,
  glowThreshold: 0.0,

  // Animation properties
  lerpSpeed: 0.05,
  audioLerpSpeed: 0.069,

  // Audio properties
  audioEnabled: true,
  audioSensitivity: 1.0,
  audioSmoothing: 0.8,
  frequencyBands: 32,
  bassResponse: 1.2,
  midResponse: 1.0,
  trebleResponse: 0.8,
  plasmaVolumeReactivity: 2.0,
  volumeThreshold: 0.15,
};

const interpolatedProps = [
  // Core plasma properties
  "effectScale",
  "intensity",
  "radius",
  "rayLength",
  "glowFalloff",
  "glowThreshold",

  // Ring properties
  "ringCount",
  "ringVisibility",
  "ringDistance",
  "ringSpread",
  "ringBounce",
  "ringThickness",
  "ringVariance",
  "ringSharpness",
  "ringAmplitude",
  "ringSpeed",
  "ringSegments",
  "ringColorInheritance",
];

const immediateProps = ["colorCycleSpeed", "plasmaSpeed", "blendMode"];

const hexToRgb = (hex: string): THREE.Vector3 => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? new THREE.Vector3(
        parseInt(result[1], 16) / 255,
        parseInt(result[2], 16) / 255,
        parseInt(result[3], 16) / 255,
      )
    : new THREE.Vector3(1, 1, 1);
};

const Plasma = memo(
  forwardRef<PlasmaRef, PlasmaProps>(
    (
      {
        width,
        height,
        className,
        style,
        initialConfig = {},
        onReady,
        pixelRatio,
        powerPreference = "high-performance",
        alpha = false,
        antialias = true,
        preserveDrawingBuffer = false,
        fallbackContent,
        audioTrack,
      },
      ref,
    ) => {
      const canvasRef = useRef<HTMLCanvasElement>(null);
      const sceneRef = useRef<THREE.Scene | null>(null);
      const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
      const materialRef = useRef<THREE.ShaderMaterial | null>(null);
      const frameRef = useRef<number | null>(null);
      const startTimeRef = useRef<number>(Date.now());
      const isVisibleRef = useRef<boolean>(true);
      const hasWebGLRef = useRef<boolean>(true);

      const configRef = useRef<Required<PlasmaConfig>>({
        ...defaultConfig,
        ...initialConfig,
      });
      const targetRef = useRef<
        Record<
          string,
          number | boolean | { x: number; y: number } | THREE.Vector3
        >
      >({});
      const currentRef = useRef<
        Record<
          string,
          number | boolean | { x: number; y: number } | THREE.Vector3
        >
      >({});

      // Audio analysis refs
      const audioContextRef = useRef<AudioContext | null>(null);
      const analyserRef = useRef<AnalyserNode | null>(null);
      const sourceRef = useRef<MediaStreamAudioSourceNode | null>(null);
      const audioDataRef = useRef<Float32Array | null>(null);
      const smoothedAudioRef = useRef<Float32Array | null>(null);

      // Helper functions
      const lerp = (a: number, b: number, t: number) => a + (b - a) * t;

      const isVector = (value: unknown): value is { x: number; y: number } => {
        return (
          typeof value === "object" &&
          value !== null &&
          "x" in value &&
          "y" in value
        );
      };

      const isVector3 = (value: unknown): value is THREE.Vector3 => {
        return value instanceof THREE.Vector3;
      };

      const setShaderValue = useCallback(
        (
          property: string,
          value: number | boolean | { x: number; y: number } | THREE.Vector3,
          bypassSmoothing = false,
        ) => {
          if (property in targetRef.current) {
            targetRef.current[property] = value;
            if (
              (immediateProps.includes(property) || bypassSmoothing) &&
              materialRef.current?.uniforms[property]
            ) {
              materialRef.current.uniforms[property].value = value;
              // If bypassing smoothing, also update current value with audio lerp speed
              if (bypassSmoothing && property in currentRef.current) {
                const current = currentRef.current[property];
                if (typeof current === "number" && typeof value === "number") {
                  currentRef.current[property] = lerp(
                    current,
                    value,
                    configRef.current.audioLerpSpeed,
                  );
                }
              }
            }
          }
        },
        [],
      );

      const processAudioData = useCallback(() => {
        if (
          !analyserRef.current ||
          !audioDataRef.current ||
          !smoothedAudioRef.current ||
          !configRef.current.audioEnabled
        ) {
          return null;
        }

        analyserRef.current.getFloatFrequencyData(audioDataRef.current);

        const bands = configRef.current.frequencyBands;
        const sensitivity = configRef.current.audioSensitivity;

        // Calculate the size of each frequency band
        const bandSize = Math.floor(audioDataRef.current.length / bands);
        const bandValues = new Float32Array(bands);

        // Process each frequency band
        for (let i = 0; i < bands; i++) {
          let bandSum = 0;
          // Sum up the values for this frequency band
          for (let j = 0; j < bandSize; j++) {
            const index = i * bandSize + j;
            const rawValue = (audioDataRef.current[index] + 140) / 140; // Normalize from -140 to 0 dB
            bandSum += Math.max(0, Math.min(1, rawValue));
          }
          // Average the band values
          const bandAverage = bandSum / bandSize;
          // Apply smoothing using existing lerping
          smoothedAudioRef.current[i] = bandAverage;
          bandValues[i] = bandAverage;
        }

        // Calculate overall volume from all bands
        const volume =
          (bandValues.reduce((a, b) => a + b, 0) / bands) * sensitivity;

        return {
          bandValues,
          volume,
          spectrum: smoothedAudioRef.current,
        };
      }, []);

      const applyAudioReactivity = useCallback(() => {
        const audioData = processAudioData();
        if (!audioData) return;

        const { volume, bandValues } = audioData;
        const reactivity = configRef.current.plasmaVolumeReactivity;
        const threshold = configRef.current.volumeThreshold;

        // Add threshold and compress volume range
        const compressedVolume =
          volume < threshold ? 0 : (volume - threshold) / (1 - threshold); // Compress remaining range to 0-1

        // Create a more dynamic response to volume
        const volumeResponse = Math.pow(compressedVolume, 1.5) * reactivity;

        // Apply volume reactivity to core plasma properties with more dynamic scaling
        setShaderValue(
          "intensity",
          configRef.current.intensity * (1 + volumeResponse * 1),
          true,
        );
        setShaderValue(
          "radius",
          configRef.current.radius * (1 + volumeResponse * 0.6),
          true,
        );
        setShaderValue(
          "effectScale",
          configRef.current.effectScale * (1 - volumeResponse * 0.5),
          true,
        );
        setShaderValue(
          "glowFalloff",
          configRef.current.glowFalloff * (1 - volumeResponse * 0.25),
          true,
        );
        setShaderValue(
          "colorCycleSpeed",
          configRef.current.colorCycleSpeed * (1 - volumeResponse * 0.03),
          true,
        );
        setShaderValue(
          "plasmaSpeed",
          configRef.current.plasmaSpeed * (1 - volumeResponse * 0.25),
          true,
        );

        // Only adjust ring properties if we have significant audio
        if (volume >= threshold) {
          // Make rings react to audio by adjusting their wave properties
          const averageFrequency =
            bandValues.reduce((a, b) => a + b, 0) / bandValues.length;
          const frequencyVariance =
            Math.max(...bandValues) - Math.min(...bandValues);

          // Set ring visibility to 1 and adjust thickness based on audio
          setShaderValue("ringVisibility", 1.0, true);
          setShaderValue(
            "ringThickness",
            configRef.current.ringThickness *
              configRef.current.ringThicknessAudio,
            false,
          );
          setShaderValue(
            "ringDistance",
            configRef.current.ringDistance - frequencyVariance * 0.1,
            false,
          );

          // Adjust ring wave properties based on audio
          setShaderValue(
            "ringAmplitude",
            configRef.current.ringAmplitude * (1 + averageFrequency * 3),
            true,
          );
          setShaderValue(
            "ringSpeed",
            configRef.current.ringSpeed * (1 + frequencyVariance * 1),
            true,
          );
          setShaderValue(
            "ringVariance",
            configRef.current.ringVariance * (1 + frequencyVariance),
            true,
          );
        } else {
          // When no significant audio, smoothly return to default values
          setShaderValue(
            "ringVisibility",
            configRef.current.ringVisibility,
            false,
          );
          setShaderValue(
            "ringThickness",
            configRef.current.ringThickness,
            false,
          );
          setShaderValue("ringDistance", configRef.current.ringDistance, false);
          setShaderValue(
            "ringAmplitude",
            configRef.current.ringAmplitude,
            false,
          );
          setShaderValue("ringSpeed", configRef.current.ringSpeed, false);
          setShaderValue("ringVariance", configRef.current.ringVariance, false);
        }
      }, [processAudioData, setShaderValue]);

      const updateInterpolation = useCallback(() => {
        if (!materialRef.current) return;

        const lerpSpeed = configRef.current.lerpSpeed;

        interpolatedProps.forEach((prop) => {
          if (prop in targetRef.current && prop in currentRef.current) {
            const current = currentRef.current[prop];
            const target = targetRef.current[prop];
            if (typeof current === "number" && typeof target === "number") {
              // Use lerpSpeed for normal transitions
              currentRef.current[prop] = lerp(current, target, lerpSpeed);
              if (materialRef.current!.uniforms[prop]) {
                materialRef.current!.uniforms[prop].value =
                  currentRef.current[prop];
              }
            }
          }
        });

        // Update vector properties
        if (targetRef.current.effectCenter && currentRef.current.effectCenter) {
          const current = currentRef.current.effectCenter;
          const target = targetRef.current.effectCenter;
          if (isVector(current) && isVector(target)) {
            current.x = lerp(current.x, target.x, lerpSpeed);
            current.y = lerp(current.y, target.y, lerpSpeed);
            materialRef.current!.uniforms.effectCenter.value.set(
              current.x,
              current.y,
            );
          }
        }

        // Update colors
        ["color1", "color2", "color3", "backgroundColor"].forEach(
          (colorKey) => {
            if (targetRef.current[colorKey] && currentRef.current[colorKey]) {
              const target = targetRef.current[colorKey];
              const current = currentRef.current[colorKey];
              if (
                target instanceof THREE.Vector3 &&
                current instanceof THREE.Vector3
              ) {
                current.x = lerp(current.x, target.x, lerpSpeed);
                current.y = lerp(current.y, target.y, lerpSpeed);
                current.z = lerp(current.z, target.z, lerpSpeed);
                materialRef.current!.uniforms[colorKey].value.set(
                  current.x,
                  current.y,
                  current.z,
                );
              }
            }
          },
        );
      }, []);

      const animate = useCallback(() => {
        if (
          !rendererRef.current ||
          !sceneRef.current ||
          !materialRef.current ||
          !isVisibleRef.current
        )
          return;

        // Apply audio reactivity if enabled
        if (audioTrack && configRef.current.audioEnabled) {
          applyAudioReactivity();
        }

        updateInterpolation();
        materialRef.current.uniforms.iTime.value =
          (Date.now() - startTimeRef.current) * 0.001;

        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        rendererRef.current.render(sceneRef.current, camera);
        frameRef.current = requestAnimationFrame(animate);
      }, [updateInterpolation, applyAudioReactivity, audioTrack]);

      const updateConfig = useCallback((newConfig: Partial<PlasmaConfig>) => {
        Object.entries(newConfig).forEach(([key, value]) => {
          if (value !== undefined) {
            const configKey = key as keyof PlasmaConfig;
            (configRef.current[configKey] as typeof value) = value;

            if (key === "effectCenter" && typeof value === "object") {
              targetRef.current[key] = { ...value };
            } else if (key.includes("color") || key === "backgroundColor") {
              targetRef.current[key] = hexToRgb(value as string);
            } else {
              targetRef.current[key] = value as
                | number
                | boolean
                | { x: number; y: number };
            }

            // Update immediate properties directly
            if (
              immediateProps.includes(key) &&
              materialRef.current?.uniforms[key]
            ) {
              materialRef.current.uniforms[key].value = value;
            }

            // Update non-interpolated properties
            if (
              key === "useCustomColors" &&
              materialRef.current?.uniforms.useCustomColors
            ) {
              materialRef.current.uniforms.useCustomColors.value =
                value as boolean;
            }
            if (key === "lerpSpeed") {
              configRef.current.lerpSpeed = value as number;
            }
          }
        });
      }, []);

      const getConfig = useCallback(() => ({ ...configRef.current }), []);

      const resetToDefaults = useCallback(() => {
        updateConfig(defaultConfig);
      }, [updateConfig]);

      useImperativeHandle(
        ref,
        () => ({
          updateConfig,
          getConfig,
          resetToDefaults,
        }),
        [updateConfig, getConfig, resetToDefaults],
      );

      // Audio setup effect
      useEffect(() => {
        if (!audioTrack || !configRef.current.audioEnabled) {
          // Cleanup if no audio track
          if (sourceRef.current) {
            sourceRef.current.disconnect();
            sourceRef.current = null;
          }
          if (audioContextRef.current) {
            audioContextRef.current.close();
            audioContextRef.current = null;
          }
          return;
        }

        // Setup audio analysis
        const setupAudio = async () => {
          try {
            audioContextRef.current = new AudioContext();
            analyserRef.current = audioContextRef.current.createAnalyser();
            analyserRef.current.fftSize = configRef.current.frequencyBands * 2;
            analyserRef.current.smoothingTimeConstant = 0.8;

            const stream = new MediaStream([audioTrack]);
            sourceRef.current =
              audioContextRef.current.createMediaStreamSource(stream);
            sourceRef.current.connect(analyserRef.current);

            const bufferLength = analyserRef.current.frequencyBinCount;
            audioDataRef.current = new Float32Array(bufferLength);
            smoothedAudioRef.current = new Float32Array(bufferLength);
            smoothedAudioRef.current.fill(0);
          } catch (error) {
            console.error("Error setting up audio analysis:", error);
          }
        };

        setupAudio();

        return () => {
          if (sourceRef.current) {
            sourceRef.current.disconnect();
          }
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
        };
      }, [audioTrack]);

      useEffect(() => {
        if (!canvasRef.current) return;

        // Check WebGL support
        const testCanvas = document.createElement("canvas");
        const gl =
          testCanvas.getContext("webgl") ||
          testCanvas.getContext("experimental-webgl");
        if (!gl) {
          hasWebGLRef.current = false;
          console.warn("WebGL not supported");
          return;
        }

        const canvas = canvasRef.current;
        const canvasWidth = width || canvas.offsetWidth || window.innerWidth;
        const canvasHeight =
          height || canvas.offsetHeight || window.innerHeight;

        // Initialize Three.js with WebGL context attributes
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias,
          alpha,
          powerPreference,
          preserveDrawingBuffer,
          failIfMajorPerformanceCaveat: false,
        });
        renderer.setSize(canvasWidth, canvasHeight, false);

        // Use provided pixel ratio or auto-detect, but cap at 2 for performance
        const dpr = pixelRatio || Math.min(window.devicePixelRatio || 1, 2);
        renderer.setPixelRatio(dpr);

        // Initialize state
        interpolatedProps.forEach((prop) => {
          const value = configRef.current[prop as keyof PlasmaConfig];
          if (
            typeof value === "number" ||
            typeof value === "boolean" ||
            value instanceof THREE.Vector3 ||
            isVector(value)
          ) {
            targetRef.current[prop] = value;
            currentRef.current[prop] = value;
          }
        });

        immediateProps.forEach((prop) => {
          const value = configRef.current[prop as keyof PlasmaConfig];
          if (
            typeof value === "number" ||
            typeof value === "boolean" ||
            value instanceof THREE.Vector3 ||
            isVector(value)
          ) {
            targetRef.current[prop] = value;
          }
        });

        targetRef.current.effectCenter = { ...configRef.current.effectCenter };
        currentRef.current.effectCenter = { ...configRef.current.effectCenter };

        ["color1", "color2", "color3", "backgroundColor"].forEach(
          (colorKey) => {
            const hex = configRef.current[
              colorKey as keyof PlasmaConfig
            ] as string;
            targetRef.current[colorKey] = hexToRgb(hex);
            currentRef.current[colorKey] = hexToRgb(hex);
          },
        );

        // Create uniforms
        const uniforms = {
          iTime: { value: 0 },
          iResolution: { value: new THREE.Vector2(canvasWidth, canvasHeight) },
          intensity: { value: currentRef.current.intensity },
          radius: { value: currentRef.current.radius },
          blendMode: { value: configRef.current.blendMode },
          effectScale: { value: currentRef.current.effectScale },
          effectCenter: {
            value: new THREE.Vector2(
              currentRef.current.effectCenter.x,
              currentRef.current.effectCenter.y,
            ),
          },
          color1: {
            value: isVector3(currentRef.current.color1)
              ? currentRef.current.color1.clone()
              : new THREE.Vector3(),
          },
          color2: {
            value: isVector3(currentRef.current.color2)
              ? currentRef.current.color2.clone()
              : new THREE.Vector3(),
          },
          color3: {
            value: isVector3(currentRef.current.color3)
              ? currentRef.current.color3.clone()
              : new THREE.Vector3(),
          },
          useCustomColors: { value: configRef.current.useCustomColors },
          colorCycleSpeed: { value: configRef.current.colorCycleSpeed },
          ringCount: { value: currentRef.current.ringCount },
          ringVisibility: { value: currentRef.current.ringVisibility },
          ringDistance: { value: currentRef.current.ringDistance },
          ringSpread: { value: currentRef.current.ringSpread },
          ringBounce: { value: currentRef.current.ringBounce },
          ringThickness: { value: currentRef.current.ringThickness },
          ringVariance: { value: currentRef.current.ringVariance },
          ringSharpness: { value: currentRef.current.ringSharpness },
          ringAmplitude: { value: currentRef.current.ringAmplitude },
          ringSpeed: { value: configRef.current.ringSpeed },
          ringSegments: { value: currentRef.current.ringSegments },
          ringColorInheritance: {
            value: currentRef.current.ringColorInheritance,
          },
          backgroundColor: {
            value: isVector3(currentRef.current.backgroundColor)
              ? currentRef.current.backgroundColor.clone()
              : new THREE.Vector3(),
          },
          plasmaSpeed: { value: configRef.current.plasmaSpeed },
          rayLength: { value: currentRef.current.rayLength },
          glowFalloff: { value: currentRef.current.glowFalloff },
          glowThreshold: { value: currentRef.current.glowThreshold },
        };

        const material = new THREE.ShaderMaterial({
          uniforms,
          vertexShader,
          fragmentShader,
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        sceneRef.current = scene;
        rendererRef.current = renderer;
        materialRef.current = material;

        // Handle resize with ResizeObserver
        const resizeObserver = new ResizeObserver(() => {
          if (!renderer || !material) return;

          const { width: newWidth, height: newHeight } =
            canvas.getBoundingClientRect();

          // Only update if size actually changed
          if (newWidth > 0 && newHeight > 0) {
            renderer.setSize(newWidth, newHeight, false);
            material.uniforms.iResolution.value.set(newWidth, newHeight);
          }
        });

        // Observe the canvas element
        resizeObserver.observe(canvas);

        // Visibility handling for performance
        const handleVisibilityChange = () => {
          isVisibleRef.current = !document.hidden;
          if (isVisibleRef.current && !frameRef.current) {
            animate();
          }
        };

        // Error handling
        const handleContextLost = (event: Event) => {
          event.preventDefault();
          if (frameRef.current) {
            cancelAnimationFrame(frameRef.current);
            frameRef.current = null;
          }
        };

        const handleContextRestored = () => {
          // Reinitialize if needed
          animate();
        };

        document.addEventListener("visibilitychange", handleVisibilityChange);
        canvas.addEventListener("webglcontextlost", handleContextLost);
        canvas.addEventListener("webglcontextrestored", handleContextRestored);

        // Start animation
        animate();

        // Notify ready
        if (onReady) {
          onReady();
        }

        return () => {
          resizeObserver.disconnect();
          document.removeEventListener(
            "visibilitychange",
            handleVisibilityChange,
          );
          canvas.removeEventListener("webglcontextlost", handleContextLost);
          canvas.removeEventListener(
            "webglcontextrestored",
            handleContextRestored,
          );
          if (frameRef.current) {
            cancelAnimationFrame(frameRef.current);
          }
          renderer.dispose();
          material.dispose();
          geometry.dispose();
        };
      }, [
        width,
        height,
        animate,
        onReady,
        pixelRatio,
        powerPreference,
        alpha,
        antialias,
        preserveDrawingBuffer,
      ]);

      if (!hasWebGLRef.current && fallbackContent) {
        return <>{fallbackContent}</>;
      }

      return (
        <canvas
          ref={canvasRef}
          className={className}
          style={{
            display: "block",
            width: "100%",
            height: "100%",
            touchAction: "none",
            ...style,
          }}
        />
      );
    },
  ),
);

Plasma.displayName = "Plasma";

export default Plasma;

export type { PlasmaConfig };



================================================
FILE: src/visualizers/webgl/PlasmaVisualizer.tsx
================================================
import {
  usePipecatClientMediaTrack,
  usePipecatClientTransportState,
} from "@pipecat-ai/client-react";
import { useEffect, useRef } from "react";
import { Plasma, type PlasmaConfig, type PlasmaRef } from ".";

const defaultConfig: PlasmaConfig = {
  effectScale: 0.55,
  ringDistance: 0,
  ringBounce: 0.0,
  ringVariance: 0.35,
  ringAmplitude: 0.03,
  ringVisibility: 0.32,
  ringSegments: 6,
  ringThickness: 8,
  ringSpread: 0.08,
  colorCycleSpeed: 0.5,
  intensity: 1.95,
  radius: 1.65,
  glowFalloff: 1,
  glowThreshold: 0,
  plasmaSpeed: 0.3,
  rayLength: 1,
};

const thinkingConfig: PlasmaConfig = {
  ringDistance: 0.05,
  ringBounce: 0.25,
  ringVariance: 0.0,
  ringAmplitude: 0,
  ringVisibility: 0.3,
  ringThickness: 18,
  colorCycleSpeed: 3,
  intensity: 2,
  radius: 2.0,
  glowThreshold: 0.0,
  glowFalloff: 0.5,
  plasmaSpeed: 3,
  rayLength: 1,
};

const connectedConfig: PlasmaConfig = {
  ...defaultConfig,
};

export const PlasmaVisualizer = () => {
  const transportState = usePipecatClientTransportState();
  const audioTrack = usePipecatClientMediaTrack("audio", "bot");

  const shaderRef = useRef<PlasmaRef>(null);

  useEffect(() => {
    switch (transportState) {
      case "disconnected":
        shaderRef.current?.updateConfig(defaultConfig);
        break;
      case "ready":
        shaderRef.current?.updateConfig(connectedConfig);
        break;
      default:
        shaderRef.current?.updateConfig(thinkingConfig);
        break;
    }
  }, [transportState]);

  return (
    <Plasma
      ref={shaderRef}
      initialConfig={defaultConfig}
      className="vkui:absolute vkui:inset-0 vkui:pointer-events-none vkui:animate-fade-in vkui:z-0"
      audioTrack={audioTrack}
    />
  );
};

export default PlasmaVisualizer;



================================================
FILE: .github/workflows/build.yml
================================================
name: Build Check

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - '*'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci --include=dev
      
    - name: Build
      run: npm run build



================================================
FILE: .github/workflows/publish-current.yml
================================================
name: Publish Current Version

on:
  workflow_dispatch:
    inputs:
      tag_type:
        description: 'Tag type for npm publish'
        required: true
        default: 'latest'
        type: choice
        options:
          - latest
          - dev
          - beta
          - alpha

jobs:
  publish-current:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci --include=dev

      - name: Get current version
        id: package_version
        uses: martinbeentjes/npm-get-version-action@v1.3.1

      - name: Build package
        run: npm run build

      - name: Publish to NPM
        run: npm publish --tag ${{ github.event.inputs.tag_type }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.package_version.outputs.current-version }}
          release_name: Release v${{ steps.package_version.outputs.current-version }}
          draft: false
          prerelease: false 


================================================
FILE: .github/workflows/publish.yml
================================================
name: Bump and Publish

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - rc

jobs:
  bump-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci --include=dev

      - name: Configure Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions@github.com'

      - name: Bump version
        id: bump_version
        run: |
          if [ "${{ github.event.inputs.version_type }}" = "rc" ]; then
            npm version prerelease --preid=rc
          else
            npm version ${{ github.event.inputs.version_type }}
          fi
      
      - name: Get version
        id: package_version
        uses: martinbeentjes/npm-get-version-action@v1.3.1

      - name: Build package
        run: npm run build

      - name: Publish to NPM
        run: |
          if [ "${{ github.event.inputs.version_type }}" = "rc" ]; then
            npm publish --tag dev
          else
            npm publish --tag latest
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Push changes
        run: |
          git push
          git push --tags

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.package_version.outputs.current-version }}
          release_name: Release v${{ steps.package_version.outputs.current-version }}
          draft: false
          prerelease: ${{ github.event.inputs.version_type == 'rc' }}


================================================
FILE: .ladle/components.tsx
================================================
import type { GlobalProvider } from "@ladle/react";
import React, { useEffect } from "react";
import { ThemeProvider } from "../src/components/ThemeProvider";
import "./theme.css";

export const Provider: GlobalProvider = ({ children, globalState }) => {
  useEffect(() => {
    if (globalState.theme === "dark") {
      document.documentElement.classList.add("vkui:dark");
    } else {
      document.documentElement.classList.remove("vkui:dark");
    }
  }, [globalState.theme]);
  return <ThemeProvider>{children}</ThemeProvider>;
};



================================================
FILE: .ladle/theme.css
================================================
@import "../src/index.css";
@source "../src/components/";
@source "../src/templates/";


